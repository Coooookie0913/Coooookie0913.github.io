<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>P0</title>
    <url>/2023/01/02/P0/</url>
    <content><![CDATA[<h1 id="P0-Study"><a href="#P0-Study" class="headerlink" title="P0_Study"></a>P0_Study</h1><h2 id="电路分析设计"><a href="#电路分析设计" class="headerlink" title="电路分析设计"></a>电路分析设计</h2><ol>
<li>Input与Output分析</li>
<li>功能分析<br>（可以先进行类似于表格的书面化说明，明白好设计思路与设计需求再去设计电路）</li>
<li>分层设计与分模块设计<br>模块类似于函数的封装，便于理清思路、清晰电路、debug<br>eg1.Moore机与Mealy机都可以划分为状态转移、状态存储、输出模块<br>eg2.32位加法器分为多个一位加法器<br>PS：注意子电路的<strong>appearance</strong>，要跟题目要求一致</li>
</ol>
<h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>首先回顾一下Moore和Mealy叭！<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P0/Moore&Mealy.png"
                      alt="1"
                ></p>
<ol>
<li>状态转移电路一般只是<strong>组合逻辑</strong>的计算，也就是说随着input的变化（无论clk处于什么状态），其计算的状态也相应发生，所以一定要有<em>状态存储</em>模块，clk处于上升沿时输出prev_state存入now_state</li>
<li>对于组合逻辑部分，画好状态转移图，一个经济有效的方法就是<em>打表</em>，利用analyze circuit来实现  </li>
<li>一定弄清题目对于输出的要求，<em>正确使用register</em></li>
</ol>
<h2 id="线路颜色不对报错"><a href="#线路颜色不对报错" class="headerlink" title="线路颜色不对报错"></a>线路颜色不对报错</h2><p>小结：</p>
<ol>
<li>红色 E 的可能原因：短路&#x2F;多驱动，门电路没接输入，多驱动即相当于多个逻辑运算assign同一个output，这当然是不行的</li>
<li>状态转移模块是组合逻辑，不需要时钟，不需要 reset</li>
<li>真值表生成电路功能的使用  </li>
<li>不要在组合逻辑电路中出现环路，否则会出现震荡！</li>
</ol>
<h2 id="question"><a href="#question" class="headerlink" title="question"></a>question</h2><ol>
<li>register的使用（navigation那里）<br>①先把问题转化成有限状态机，再把有限状态机实现成电路<br>②每个时钟上升沿到来，更新寄存器的值</li>
<li>三态问题？什么时候用三态？（好像三态的输入用逻辑门运算会变红）<br>不用考虑三态</li>
<li>二进制减法qaq不会（主要是ftoi那里）<br>扩展为32位，再用0去减<br>用0去减其实与非门等效</li>
</ol>
<h2 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P0/CRC%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF.png"
                      alt="1"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P0/CRC%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B.png"
                      alt="1"
                ></p>
<ol>
<li>体现了模块化的思想</li>
<li>要审题，题目说了被除数是要拼接的</li>
<li>注意splitter的最高位最低位以及数据的最高位最低为的对应，不要反了！</li>
</ol>
<h2 id="GRF"><a href="#GRF" class="headerlink" title="GRF"></a>GRF</h2><p>题目不难，注意线路很杂的时候要看有没有接上或者接错，CTRL CV 的时候tunnel要改完改对</p>
<h2 id="ftoi"><a href="#ftoi" class="headerlink" title="ftoi"></a>ftoi</h2><ol>
<li>二进制浮点数小数点几位，相当于右移几位；乘2^n想当于左移（正数），注意要先左移再右移，否则就丢失掉后面的数据位了</li>
<li>二进制减法？不会qaq</li>
<li>计算负数的补码，取反（非门计算）+1，（？2^n-x感觉是不是不太行，因为n达不到32位） </li>
<li>学会试着使用simulate-logging功能debug</li>
</ol>
<h2 id="navigation"><a href="#navigation" class="headerlink" title="navigation"></a>navigation</h2><ol>
<li>状态转移打表 “课上课下打表最经济有效”————董老 salute！<br>此处状态转移以及hit都可以打表得到（注意打表的时候输入输出都只能是一位，这里需要splitter套层皮，同样是注意高低位）</li>
<li>太憨了！看好输入输出要求，是否提供clk，如果clk是一个input就不要再自己放一个clk了，太憨。</li>
<li>注意状态存储部分要符合题目要求</li>
<li>状态转移打表、register存储、input和prev_state决定输出，这些没什么好说的</li>
<li>What deserves special mention is 注意这里利用MUX实现了同步复位，因为后面有register，只有clk处于上升沿，这个clr才是有效的（组合逻辑是不是们没有任何延迟？目前是的）</li>
</ol>
<h2 id="祝上机顺利！"><a href="#祝上机顺利！" class="headerlink" title="祝上机顺利！"></a>祝上机顺利！</h2><h1 id="P0-Review"><a href="#P0-Review" class="headerlink" title="P0_Review"></a>P0_Review</h1><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>首先恭喜帆帆顺利通过P0，再接再厉！</p>
<h2 id="五人投票"><a href="#五人投票" class="headerlink" title="五人投票"></a>五人投票</h2><ol>
<li>题意描述：四个组员（00-11）一个组长，组长可以投屏蔽票，并指定一人屏蔽他的投票，组员是赞成、反对、弃权，组长是赞成、反对、弃权、屏蔽，若赞成票数大于反对票数，则输出1，否则输出0</li>
<li>主要思路：首先用比较器判断每个人是投赞成还是反对（是则对应输出为1，组长投屏蔽票时，则其对应的赞成和反对的输出都为0；组员的统计使用了一个mux，如果是被屏蔽了则把其输入置为弃权票），然后分别把赞成和反对的票数相加，最后用一个比较器绝定输出</li>
<li>错误：①使用比较器的时候习惯性连亮着的点，连错端口<br>②比较器要置为unsigned（根据数据类型决定比较器的参数属性）<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P0/%E6%AF%94%E8%BE%83%E5%99%A81.jpg"
                      alt="1"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P0/%E6%AF%94%E8%BE%83%E5%99%A82.jpg"
                      alt="1"
                ></li>
<li>优化：线路过于凌乱复杂，评论区给出了更好的解决方法<br>使用bit adder而非那么多加法器<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P0/bit%20adder.png"
                      alt="1"
                ></li>
</ol>
<h2 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h2><ol>
<li>本题要求一个mealy机来匹配字符串0121（输出01）和1210（输出10），无匹配则输出00</li>
<li>解题思路：基本的mealy型状态机，即数据输入、状态转移、状态存储、状态输出。其中状态转移和状态输出打表解决。这里需要注意的是有九个状态，状态转移很复杂，一不小心就会出错。</li>
<li>错误：①注意输入0把之前的输入失配之后，应转移到已匹配一个0的情况而非初始状态<br>②已匹配0121后，再输入0，则匹配到1210；再输入2，转移到匹配了12的状态<br>反正就多注意吧，仔细一点</li>
<li>优化：利用高老师上课讲的移位的方法，使用三个串联寄存器或者三位的移位寄存器（因为此处只是mealy机），用每一次输入之后input、s0、s1、s2来分别与0121和1210比较<br>三个寄存器串联<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P0/P0L2%E4%B8%89%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A81.png"
                      alt="1"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P0/P0L2%E4%B8%89%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A82.png"
                      alt="1"
                ><br><strong>注意</strong> 此处需要给寄存器赋一个并不会出现的初值3，否则寄存器默认初始值0，则会使匹配出现问题<br>使用移位寄存器<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P0/%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8.jpg"
                      alt="1"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P0/P0L2%E7%A7%BB%E4%BD%8D%E5%99%A8%E5%AE%9E%E7%8E%B0.jpg"
                      alt="1"
                ><br><strong>注意</strong> 此处也是赋初值问题，为了避免初始默认0造成的影响，同学提供了在最高位加上1校验的方法（00-&gt;100,01-&gt;101 etc）</li>
<li>后记：认真听讲，多去思考讨论，学习简洁优美的思路</li>
</ol>
<h2 id="类斐波那契"><a href="#类斐波那契" class="headerlink" title="类斐波那契"></a>类斐波那契</h2><p>斐波那契好像是P0绕不过去的点了，就是一年比一年复杂qaq。不应该着急走的，其实慢慢做，静心想，也没有很难！<br>题目：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P0/P0L3%E9%A2%98%E7%9B%AE.png"
                      alt="1"
                ><br>这里提供一个讨论区使用移位寄存器的方法，使用寄存器串联同理<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P0/P0L3%E5%AF%84%E5%AD%98%E5%99%A8%E5%AE%9E%E7%8E%B0.png"
                      alt="1"
                ></p>
<ol>
<li>计数器在第一个时钟上升沿结束后变成1</li>
<li>每个时钟上升沿到来都会立即把s_x存入移位寄存器，然后相应后面的s_x又会更新，因为是组合逻辑。在第n个时钟上升沿到来把f(n-1)存入了移位寄存器，此时s_x也改变为f(n),所以第n+1个时钟上升沿到来时，f(n)存入结果寄存器</li>
<li>时钟端口除了时钟外，尽量不要接其他东西，不要参与计算逻辑</li>
<li>主要是弄懂核心的迭代，对于输出周期，可以多一个少一个自己调一调，也就好了~</li>
</ol>
]]></content>
      <categories>
        <category>BUAA_CO</category>
      </categories>
      <tags>
        <tag>BUAA_CO</tag>
      </tags>
  </entry>
  <entry>
    <title>P1</title>
    <url>/2023/01/02/P1/</url>
    <content><![CDATA[<h1 id="P1-Study"><a href="#P1-Study" class="headerlink" title="P1_Study"></a>P1_Study</h1><h2 id="《Verilog数字系统设计》语法部分学习"><a href="#《Verilog数字系统设计》语法部分学习" class="headerlink" title="《Verilog数字系统设计》语法部分学习"></a>《Verilog数字系统设计》语法部分学习</h2><h3 id="基本常识"><a href="#基本常识" class="headerlink" title="基本常识"></a>基本常识</h3><ol>
<li>Verilog HDL程序是由模块构成的，每个模块的内容都是位于module和endmodule两个语句之间</li>
<li>Verilog模块可以分为两种：<br>①使模块最终生成电路的结构<br>②测试模块testbench</li>
<li>端口定义、IO说明、除endmodule外，每个语句和数据定义后必须有分号</li>
</ol>
<h3 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h3><ol>
<li>assign用于建模组合逻辑，always用于建模时序逻辑或者组合逻辑，但是<code>always @*</code> 有时候容易出问题，不建议使用，且区分不清reg到底是组合还是寄存器。组合逻辑比较复杂，可以使用<code>assign + function</code></li>
<li>复位相关问题<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//规范的 同步复位：</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    <span class="comment">//规范的异步复位</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk,<span class="keyword">posedge</span> reset)</span><br><span class="line">    <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    <span class="comment">//如果是reset下降沿复位</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk,<span class="keyword">negedge</span> reset)</span><br><span class="line">    <span class="keyword">if</span> (~reset) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong>并行性</strong><br>①在Verilog中所有过程块（initial、always）、连续赋值语句assign、实例引用都是并行的，这三者出现的先后顺序没有关系。<br>②initial语句只执行一次，always语句一直重复活动直至仿真结束。<br>③在always模块内部，逻辑是顺序进行的。<br>④只有连续赋值语句assign和实例引用语句可以独立于过程块而存在于模块的功能定义部分。</li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol>
<li>数字<br>&lt;位宽&gt;&lt;进制&gt;&lt;数字&gt; <code>8&#39;b10101010</code><br>&lt;进制&gt;&lt;数字&gt;默认位宽至少32位<br>&lt;数字&gt;默认十进制<br>b2 o8 d10 h16<br>负数在位宽前加负号<code>-8&#39;b10101010</code><br>每个字母用8位ASCII码值表示</li>
<li>变量<br>首先说明，<strong>电路中存在的信号就是reg和wire</strong><br>①wire型变量，网络数据类型，<strong>表示结构实体（例如门）之间的物理连接</strong>，不能储存值，而且必须受到驱动器（例如门或者连续赋值语句assign）的驱动。如果没有驱动器连到网络型数据类型变量上，该变量就为高阻z。<br>Verilog程序模块中输入输出信号默认为wire型，wire可以作为任何方程式的输入，也可以用作assign语句或者实例元件的输出<br>②reg型变量，<strong>对应寄存器单元</strong>，通常用来表示always模块内的指定信号。对reg型变量赋值就像改变了一组触发器的存储单元的值。<br>需要注意reg型数据可以赋负值，但当reg型数据是一个表达式中的操作数时，它被当作无符号数，也就是正值。<br>always中的每一个信号必须被定义成reg型。<br><strong>数据的正负</strong><br>在电路中所有的数都是一个二进制数，有没有符号，只是我们去解读它的一个视角，而不是这个数本身的属性。<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] rega = <span class="number">8&#x27;b11111111</span>;</span><br><span class="line"><span class="comment">//有符号-1</span></span><br><span class="line"><span class="comment">//无符号255</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想要这个数以有符号形式比较大小或者移位运算</span></span><br><span class="line"><span class="keyword">wire</span> cond;</span><br><span class="line"><span class="keyword">assign</span> cond = <span class="built_in">$signed</span>(rega) &gt; <span class="built_in">$signed</span>(-<span class="number">2</span>);</span><br><span class="line"><span class="comment">//把带signed的表达式拆分成中间变量来写，是一定不会出错的；</span></span><br><span class="line"><span class="comment">//容易犯的错误：三目运算中间用$signed,搞不清楚Verilog优先级由不加（）</span></span><br><span class="line"><span class="keyword">if</span> (cond) <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有符号就看成补码，判断相等以及加减运算其实与符号无关</span></span><br><span class="line">a = <span class="number">8&#x27;b00001010</span> (<span class="number">8&#x27;d10</span>) + <span class="number">8&#x27;b11111111</span>；</span><br><span class="line">与 + (-<span class="number">1</span>)其实没有区别</span><br><span class="line">top == -<span class="number">1</span>；<span class="comment">//同理 都以补码存储</span></span><br></pre></td></tr></table></figure></div>
③integer型变量，reg和wire才是标准电路里用到的，integer可以做循环变量（虽然reg型变量也可以做循环变量），这样可以更好的区分电路里的寄存器和循环变量。<br>Verilog被综合成电路，是n份循环体串联或并联起来，循环变量在电路中就被展开了，是实际上不存在的。<br><strong>注意:</strong> 课上题目以及后面写CPU不要轻易尝试automatic递归，不可综合,甚至就不要用Verilog去写递归，用硬件语言是去描述硬件的。</li>
<li>赋初值问题<strong>写Verilog，永远用reset来给寄存器赋初值</strong>，如果不是特别必要说明，initial都不是必要的。（除了课下的部分题目因为年代久远，可能某些测试点忘记复位信号）</li>
</ol>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ol>
<li>逻辑右移&gt;&gt;,算数右移&gt;&gt;&gt;,合理适当使用<code>$signed()</code>以及位拼接运算符<code>&#123;&#125;</code></li>
<li>非阻塞赋值 <code>b &lt;= a</code><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P1/%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC.jpg"
                      alt="1"
                ><br>在编写可综合程序时，这是最常用的方法，always建模时序逻辑一般都使用非阻塞赋值  </li>
<li>阻塞赋值 <code>b = a</code><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P1/%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC.jpg"
                      alt="1"
                ></li>
</ol>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> () </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></div>
<p>条件语句必须在过程块语句中使用（initial&#x2F;always），并且在条件语句中也要合理使用begin-else，避免不必要的错误</p>
<h3 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h3><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span>(rega)</span><br><span class="line">    `state1: ;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">default</span>: ;<span class="comment">//将所有情况列全，避免锁存器的产生</span></span><br><span class="line"><span class="keyword">endcase</span> <span class="comment">//勿忘！</span></span><br></pre></td></tr></table></figure></div>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化memory</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] tempi;<span class="comment">//可以用reg型或者integer作循环变量</span></span><br><span class="line">        <span class="keyword">for</span>(tempi = <span class="number">0</span>;tempi &lt; memsize;tempi = tempi + <span class="number">1</span>)<span class="comment">//注意：Verilog中没有++操作</span></span><br><span class="line">        memory[tempi] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></div>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li>Verilog中控制时序和语句执行顺序的三种方式：<br>①基于延迟的时序控制<br>②基于事件的时序控制<br>③电平敏感的时序控制  </li>
<li>我们一般使用的begin-end块是顺序块，也可以给块起名<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>:  BLOCK_NAME</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></div></li>
<li>把输出变量声明为寄存器类型（maybe用的上）<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> mux4_to_1 (out,i0,i1,i2,i3,s1,s0);</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> out;</span><br><span class="line"><span class="keyword">input</span> i0,i1,i2,i3;</span><br><span class="line"><span class="keyword">input</span> s1,s0;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将输出声明为寄存器</span></span><br><span class="line"><span class="keyword">reg</span> out；</span><br><span class="line"></span><br><span class="line"><span class="comment">//组合逻辑建模</span></span><br><span class="line"><span class="keyword">always</span> @(s1,s0,i0,i1,i2,i3)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(&#123;s1,s0&#125;)<span class="comment">//位拼接</span></span><br><span class="line">        <span class="number">2&#x27;b00</span> ：out = i0;</span><br><span class="line">        <span class="number">2&#x27;b01</span> : out = i1;</span><br><span class="line">        <span class="number">2&#x27;b10</span> : out = i2;</span><br><span class="line">        <span class="number">2&#x27;b11</span> : out = i3;</span><br><span class="line">    <span class="keyword">default</span>: out = <span class="number">1&#x27;bx</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="P1-教程学习"><a href="#P1-教程学习" class="headerlink" title="P1 教程学习"></a>P1 教程学习</h2><h3 id="splitter"><a href="#splitter" class="headerlink" title="splitter"></a>splitter</h3><ol>
<li>注意模块命名</li>
<li>利用A[m:n]读取相应的位</li>
</ol>
<h3 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h3><p>注意$signed()和三目运算符的使用</p>
<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> C = (ALUOp == <span class="number">3&#x27;b000</span>) ? A + B :</span><br><span class="line">	       (ALUOp == <span class="number">3&#x27;b001</span>) ? A - B :</span><br><span class="line">		   (ALUOp == <span class="number">3&#x27;b010</span>) ? A &amp; B :</span><br><span class="line">		   (ALUOp == <span class="number">3&#x27;b011</span>) ? A | B :</span><br><span class="line">		   (ALUOp == <span class="number">3&#x27;b100</span>) ? A &gt;&gt; B :</span><br><span class="line">		   (ALUOp == <span class="number">3&#x27;b101</span>) ? <span class="built_in">$signed</span>(<span class="built_in">$signed</span>(A) &gt;&gt;&gt; B):<span class="comment">//合理使用$signed()</span></span><br><span class="line">		   <span class="number">32&#x27;b0</span>;</span><br></pre></td></tr></table></figure></div>
<h3 id="EXT"><a href="#EXT" class="headerlink" title="EXT"></a>EXT</h3><ol>
<li>注意操作数和功能序号的区别</li>
<li>$signed() 逻辑右移 算数右移<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> ext = (EOp == <span class="number">2&#x27;b00</span>) ? &#123;<span class="built_in">$signed</span>(imm) &gt;&gt;&gt; <span class="number">16</span>,imm&#125; :</span><br><span class="line">	         (EOp == <span class="number">2&#x27;b01</span>) ? &#123;<span class="number">16&#x27;b0</span>,imm&#125; :</span><br><span class="line">			 (EOp == <span class="number">2&#x27;b10</span>) ? &#123;imm,<span class="number">16&#x27;b0</span>&#125; :</span><br><span class="line">			 (EOp == <span class="number">2&#x27;b11</span>) ? &#123;<span class="built_in">$signed</span>(imm) &gt;&gt;&gt; <span class="number">16</span>,imm&#125; &lt;&lt; <span class="number">2</span> :</span><br><span class="line">			 <span class="number">32&#x27;b0</span> ;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="gray"><a href="#gray" class="headerlink" title="gray"></a>gray</h3><p>本质是时序电路：同步复位、状态转移，把格雷码当成对应的状态输出</p>
<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> Clk) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span> (Reset) <span class="keyword">begin</span></span><br><span class="line">			state &lt;= `S0;</span><br><span class="line">			isOver = <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (En) <span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">case</span> (state)</span><br><span class="line">	          `S0 : state &lt;= `S1;</span><br><span class="line">			  `S1 : state &lt;= `S2;</span><br><span class="line">			  `S2 : state &lt;= `S3;</span><br><span class="line">			  `S3 : state &lt;= `S4;</span><br><span class="line">			  `S4 : state &lt;= `S5;</span><br><span class="line">			  `S5 : state &lt;= `S6;</span><br><span class="line">			  `S6 : state &lt;= `S7;</span><br><span class="line">			  `S7 : <span class="keyword">begin</span></span><br><span class="line">				      state &lt;= `S0;</span><br><span class="line">					  isOver = <span class="number">1&#x27;b1</span>;</span><br><span class="line">				    <span class="keyword">end</span></span><br><span class="line">			  <span class="keyword">default</span>: ;</span><br><span class="line">			<span class="keyword">endcase</span>				  </span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	 <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> Overflow = isOver ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">assign</span> Output = state;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h3 id="Verilog-FSM"><a href="#Verilog-FSM" class="headerlink" title="Verilog FSM"></a>Verilog FSM</h3><ol>
<li>逻辑思考，状态编码，画出状态转移图</li>
<li>&#96;define or parameter表示状态</li>
<li>根据状态转移图构建次态逻辑与输出逻辑</li>
<li>写代码：<br>①同步复位or异步复位，复位一定要回到最原始状态<br>②合理使用if-else和case语句（case语句后一定要加上default语句，避免锁存器产生）</li>
<li>注意输出是Moore还是Mealy，可以根据波形是完整一个周期的置高还是立即置高来判断</li>
</ol>
<h3 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h3><ol>
<li>Moore机且异步复位</li>
<li>注意逻辑思考，其实可以化成两种输入（数字or符号），四种状态（nothing or F or （F + &lt;符号&gt;）or 不可能再成为F）其中F遇到数字、（F + &lt;符号&gt;）遇到符号、nothing遇到符号，都是不可挽救状态</li>
</ol>
<h3 id="BlockChecker"><a href="#BlockChecker" class="headerlink" title="BlockChecker"></a>BlockChecker</h3><ol>
<li>首先是想清楚有几种输入，几种状态</li>
<li>这里使用栈存储begin，需要注意的是撤销end或者begin的操作（这里是对end的操作有误）<br>自己可以多试几种数据比如，end begin endc ，begin end beginc 这样的<br>本地要多做测试</li>
<li>其他错误：reset没有完全初始化、define中内容打错</li>
</ol>
<h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><ol>
<li>引用宏定义记得加<code>`</code></li>
<li>状态转移搞对，不要马虎，想清楚需要什么状态，怎么转移</li>
<li>begin-end对应好，可以打一个begin打一个end，再填写中间内容，以及墙裂建议使用VScode</li>
</ol>
<h3 id="VoterPlus"><a href="#VoterPlus" class="headerlink" title="VoterPlus"></a>VoterPlus</h3><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> vote7(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">6</span>:<span class="number">0</span>] vote,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> pass</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">2</span>:<span class="number">0</span>] sum; <span class="comment">// sum为reg型变量，用于统计赞成的人数</span></span><br><span class="line">    <span class="keyword">integer</span> i; <span class="comment">// 循环变量</span></span><br><span class="line">    <span class="keyword">always</span> @(vote) <span class="keyword">begin</span> <span class="comment">// 此处使用always建模组合逻辑</span></span><br><span class="line">        sum = <span class="number">3&#x27;b000</span>; <span class="comment">// sum初值为0</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; <span class="number">7</span>;i = i + <span class="number">1</span>) <span class="keyword">begin</span> <span class="comment">// for语句</span></span><br><span class="line">            <span class="keyword">if</span> (vote[i]) sum = sum + <span class="number">1</span>; <span class="comment">// 只要有人投赞成票，则sum加1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= <span class="number">3&#x27;d4</span>) pass = <span class="number">1&#x27;b1</span>; <span class="comment">// 若大于等于4人赞成，则表决通过</span></span><br><span class="line">        <span class="keyword">else</span> pass = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div>
<p><strong>注意</strong>：在时序逻辑中不可以对同一个变量用for循环多次非阻塞赋值，最终其实只有效赋值一次，合理的解决办法：<br>①利用时序逻辑改变状态，存储状态，不存在重复赋值（例如逐位清零、置1等）<br>②利用组合逻辑可以重复对一个变量赋值，时刻变化。</p>
<h2 id="祝帆帆P1上机顺利！加油！"><a href="#祝帆帆P1上机顺利！加油！" class="headerlink" title="祝帆帆P1上机顺利！加油！"></a><strong>祝帆帆P1上机顺利！加油！</strong></h2><h1 id="P1-review"><a href="#P1-review" class="headerlink" title="P1_review"></a>P1_review</h1><h3 id="首先恭喜顺利通过P1！"><a href="#首先恭喜顺利通过P1！" class="headerlink" title="首先恭喜顺利通过P1！"></a>首先恭喜顺利通过P1！</h3><h2 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h2><p>这个与往年题一样，如果符合就最高位原样输出，如果不符合就把最高位取反。</p>
<h2 id="字符串检查"><a href="#字符串检查" class="headerlink" title="字符串检查"></a>字符串检查</h2><p>不要想多了，就是一道Moore机题，“111110”状态disc置高，“1111110”状态flag置高，“1111111+”状态err置高<br>如果你写成mealy机会发现只置高半个周期，显然不符合题意，应该是Moore机</p>
<h2 id="旅鼠"><a href="#旅鼠" class="headerlink" title="旅鼠"></a>旅鼠</h2><ol>
<li>就是hdlbits上的lemmings3，感觉不难，按状态分析就好，课下交hdlbits也过了（可能课上的if都没写最后的else？要避免锁存器的产生）</li>
<li>写testbench的时候一定要注意不能在上升沿改变input信号的值，要错开</li>
</ol>
]]></content>
      <categories>
        <category>BUAA_CO</category>
      </categories>
      <tags>
        <tag>BUAA_CO</tag>
      </tags>
  </entry>
  <entry>
    <title>P2</title>
    <url>/2023/01/02/P2/</url>
    <content><![CDATA[<h1 id="P2-Study"><a href="#P2-Study" class="headerlink" title="P2_Study"></a>P2_Study</h1><h2 id="MIPS教程-amp-大黑书学习"><a href="#MIPS教程-amp-大黑书学习" class="headerlink" title="MIPS教程&amp;大黑书学习"></a>MIPS教程&amp;大黑书学习</h2><h3 id="常用寄存器"><a href="#常用寄存器" class="headerlink" title="常用寄存器"></a>常用寄存器</h3><ol>
<li>寄存器使用规范</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P2/%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83.jpg"
                      alt="1"
                > </p>
<ol start="2">
<li><strong>注意</strong><br>在输入输出的系统调用时，会涉及对于<code>$a0</code>和<code>$v0</code>寄存器的值的改变，尤其是对于<code>$a0</code>寄存器<br>要么在主程序中避免使用（比如从<code>$a1</code>开始保存参数）<br>要么在系统调用时对于<code>$a0</code>寄存器进行保护<div class="highlight-container" data-rel="Mips"><figure class="iseeu highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保护示例</span></span><br><span class="line"><span class="meta">.macro</span> ptintInt(%src)</span><br><span class="line">  push($<span class="built_in">a0</span>) <span class="comment"># push</span></span><br><span class="line">  <span class="keyword">add </span>$<span class="built_in">a0</span>,%src,$<span class="built_in">zero</span></span><br><span class="line">  li $<span class="built_in">v0</span>,<span class="number">1</span></span><br><span class="line">  <span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span>  pop($<span class="built_in">a0</span>) <span class="comment"># pop</span></span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><ol>
<li>算术指令<br>① <code>addi add subi sub</code><br>② <code>mult</code>(低32位存入LO寄存器，高32位存入HI寄存器)<br><code>div</code>（商存入LO寄存器，余数存入HI寄存器）<br>③ <code>sll</code> (逻辑左移) <code>srl</code>(逻辑右移) <code>sra</code>（算术右移）</li>
<li>分支指令<br>① 条件分支<br>b开头的一系列指令（可以根据Mars的提示来使用）<br>需要注意的是，跳转过去之后不会返回原地址的下一条，直接跑了<br>② 跳转指令<br><code>j</code> 无条件跳转到相应标号，不返回<br><code>jal</code> 跳转与链接，跳转到相应标号并保存返回地址（可与jr $ra配合使用）<br><code>jr</code> 跳转寄存器指令，跳转到寄存器所保存的地址</li>
<li>存取指令<br>① <code>sw</code>与<code>lw</code>指令，以字为单位（4Byte）进行存取，每次存取32位<br>② <code>sb</code>与<code>lb</code>指令，以字节为单位（1Byte）进行存取<br><code>lbu</code>：将相应地址的字节（8位）装入寄存器的最低有效字节，并用0填充寄存器的剩下字节<br><code>lb</code>：同lbu，不过最后是使用符号扩展来填充寄存器的剩下字节<br><code>sb</code>：将寄存器的最低有效字节存储到指定地址字节<br>因为MIPS本就是以字节为单位操作的，所以每次对于字节操作，移位只用以1为单位即可<br>来点栗子：<div class="highlight-container" data-rel="Mips"><figure class="iseeu highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment"># $s0 = base addr of chararray $s1 = i</span></span><br><span class="line">   <span class="keyword">addi </span>$<span class="built_in">s1</span>,$<span class="built_in">zero</span>,<span class="number">0</span> <span class="comment"># i = 0</span></span><br><span class="line">   <span class="keyword">addi </span>$<span class="built_in">t0</span>,$<span class="built_in">zero</span>,<span class="number">10</span> <span class="comment"># t0 = 10</span></span><br><span class="line"><span class="symbol">loop:</span></span><br><span class="line">   <span class="keyword">beq </span>$<span class="built_in">s1</span>,$<span class="built_in">t0</span>,done <span class="comment"># i = 10,exit loop</span></span><br><span class="line">   <span class="keyword">add </span>$<span class="built_in">t1</span>,$<span class="built_in">s0</span>,$<span class="built_in">s1</span> <span class="comment"># t1 = index = addr0 + i</span></span><br><span class="line">   <span class="keyword">lb </span>$<span class="built_in">t2</span>,<span class="number">0</span>($<span class="built_in">t1</span>) <span class="comment"># t2 = array[i]</span></span><br><span class="line">   <span class="keyword">addi </span>$<span class="built_in">t2</span>,$<span class="built_in">t2</span>,-<span class="number">32</span> <span class="comment"># xiaoxie -&gt; daxie</span></span><br><span class="line">   <span class="keyword">sb </span>$<span class="built_in">t2</span>,<span class="number">0</span>($<span class="built_in">t1</span>) <span class="comment"># store the new value</span></span><br><span class="line">   <span class="keyword">addi </span>$<span class="built_in">s1</span>,$<span class="built_in">s1</span>,<span class="number">1</span> <span class="comment"># i++</span></span><br><span class="line">   <span class="keyword">j </span>loop </span><br><span class="line"><span class="symbol">done:</span></span><br><span class="line">   <span class="comment"># ......</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol>
<li>新建数组<br>注意.word与.space的区别，这里直接上评论区同学的总结<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P2/.word&.space1.jpg"
                      alt="1"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P2/.word&.space2.jpg"
                      alt="1"
                ></li>
<li>数组访问<br>注意以字为单位（int）每次移位4，以字节为单位（char）每次移位1<br>利用lb&#x2F;lbu sb lw sw 等指令实现对数组的访问和改变</li>
</ol>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a><strong>函数调用</strong></h3><p><strong>大黑书P200-P206讲得很清楚</strong></p>
<ol>
<li>函数调用与返回<br>MIPS使用jal来调用一个函数，使用jr指令从函数返回<br>jal完成两种功能：<br>①将下一条指令（jal后面的那条指令）的地址存储到寄存器$ra中<br>②跳转到目标指令<br>jr：跳转到寄存器保存的地址<br>来点栗子：<br>不涉及传参的函数<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P2/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8sample.jpg"
                      alt="1"
                ><br>带有传参和函数返回值的函数<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P2/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8sample2.jpg"
                      alt="1"
                ></li>
<li>寄存器保护<br>函数调用前后要注意保存和维护寄存器，避免被调用函数改变寄存器的值而对调用者产生影响<br>① <code>$s0</code><del><code>$s7</code> 保存局部变量时，要保护（就是调用者用到了而且调用函数可能改变的寄存器都要保护）<br>② <code>$ra</code> 要保护，这样才能知道函数返回哪里<br>③ <code>$v0</code></del><code>$v1</code> 不用保护，因为函数要将返回结果（如果有的话）存入这些寄存器中<br>利用栈来保护寄存器，使用push和pop操作</li>
<li>递归函数调用<br><strong>保护好寄存器！！！</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P2/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8.jpg"
                      alt="1"
                ></li>
<li>栈的使用<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P2/%E6%A0%88%E7%9A%84%E4%BD%BF%E7%94%A8.jpg"
                      alt="1"
                ></li>
</ol>
<h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><ol>
<li>print<div class="highlight-container" data-rel="Mips"><figure class="iseeu highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="meta">.macro</span>  printInt(%src)</span><br><span class="line">     <span class="keyword">add </span>$<span class="built_in">a0</span>,%src,$<span class="built_in">zero</span></span><br><span class="line">     li $<span class="built_in">v0</span>,<span class="number">1</span></span><br><span class="line">     <span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span>.end_macro</span><br><span class="line"></span><br><span class="line"><span class="meta">.macro</span> printStr(%src)</span><br><span class="line">     la $<span class="built_in">a0</span>,%src <span class="comment"># load label</span></span><br><span class="line">     li $<span class="built_in">v0</span>,<span class="number">4</span></span><br><span class="line">     <span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span> .end_macro</span><br></pre></td></tr></table></figure></div></li>
<li>get<div class="highlight-container" data-rel="Mips"><figure class="iseeu highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="meta">.macro</span> getInt(%des)</span><br><span class="line">     li $<span class="built_in">v0</span>,<span class="number">5</span></span><br><span class="line">     <span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span>     <span class="keyword">add </span>%des,$<span class="built_in">v0</span>,$<span class="built_in">zero</span></span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line"><span class="meta">.macro</span> getChar(%des)</span><br><span class="line">     li $<span class="built_in">v0</span>,<span class="number">12</span></span><br><span class="line">     <span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span>     <span class="keyword">add </span>%des,$<span class="built_in">v0</span>,$<span class="built_in">zero</span></span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line"><span class="meta">.macro</span> getStr(%des) <span class="comment"># contains &#x27;\n&#x27;</span></span><br><span class="line">     li $<span class="built_in">v0</span>,<span class="number">8</span></span><br><span class="line">     <span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span>     <span class="keyword">add </span>%des,$<span class="built_in">a0</span>,$<span class="built_in">zero</span></span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure></div></li>
<li>load from array<div class="highlight-container" data-rel="Mips"><figure class="iseeu highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="meta">.macro</span> loadChar(%i,%array,%des)</span><br><span class="line">     <span class="keyword">lb </span>%des,%array(%i)</span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line"><span class="meta">.macro</span> loadInt(%i,%<span class="keyword">j,%n,%array,%des)</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">mult </span>%i,%n</span><br><span class="line">    <span class="keyword">mflo </span>$<span class="built_in">t9</span></span><br><span class="line">    <span class="keyword">add </span>$<span class="built_in">t9</span>,$<span class="built_in">t9</span>,%<span class="keyword">j</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">sll </span>$<span class="built_in">t9</span>,$<span class="built_in">t9</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">lw </span>%ans,%array($<span class="built_in">t9</span>)</span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure></div></li>
<li>store to array<div class="highlight-container" data-rel="Mips"><figure class="iseeu highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="meta">.macro</span> storeInt(%i,%<span class="keyword">j,%n,%array,%src) </span><span class="comment"># n is rows </span></span><br><span class="line">     <span class="keyword">mult </span>%i,%n</span><br><span class="line">     <span class="keyword">mflo </span>$<span class="built_in">t9</span></span><br><span class="line">     <span class="keyword">add </span>$<span class="built_in">t9</span>,$<span class="built_in">t9</span>,%<span class="keyword">j</span></span><br><span class="line"><span class="keyword"></span>     <span class="keyword">sll </span>$<span class="built_in">t9</span>,$<span class="built_in">t9</span>,<span class="number">2</span></span><br><span class="line">     <span class="keyword">sw </span>%src,%array($<span class="built_in">t9</span>)</span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line"><span class="meta">.macro</span> storeChar(%i,%array,%src)</span><br><span class="line">     <span class="keyword">sb </span>%src,%array(%i)</span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure></div></li>
<li>push<div class="highlight-container" data-rel="Mips"><figure class="iseeu highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="meta">.macro</span> push(%src)</span><br><span class="line">   <span class="keyword">sw </span>%src,<span class="number">0</span>($<span class="built_in">sp</span>)</span><br><span class="line">   <span class="keyword">subi </span>$<span class="built_in">sp</span>,$<span class="built_in">sp</span>,<span class="number">4</span></span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure></div></li>
<li>pop<div class="highlight-container" data-rel="Mips"><figure class="iseeu highlight mips"><table><tr><td class="code"><pre><span class="line">   <span class="meta">.macro</span> pop(%src)</span><br><span class="line">      <span class="keyword">addi </span>$<span class="built_in">sp</span>,$<span class="built_in">sp</span>,<span class="number">4</span></span><br><span class="line">      <span class="keyword">lw </span>%src,<span class="number">0</span>($<span class="built_in">sp</span>)</span><br><span class="line">   .end_macro</span><br><span class="line"><span class="number">7</span>. end</span><br><span class="line">   ```MIPS</span><br><span class="line">   <span class="meta">.macro</span> end</span><br><span class="line">      li $<span class="built_in">v0</span>,<span class="number">10</span></span><br><span class="line">      <span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span>   .end_macro</span><br></pre></td></tr></table></figure></div></li>
<li>if-else<br>利用b类指令实现if-else的跳转，注意执行完每个块最后也要跳转，否则顺序执行</li>
<li>for<br>设置循环变量，利用b类指令实现跳转，一定不要忘记i++和最后跳回去</li>
</ol>
<h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h2><ol>
<li>写循环的时候写成死循环——忘记判断跳出循环的指令（一般放在loop开头的b类指令）；<br>忘记最后循环变量的自增操作</li>
<li>寄存器写错，比如<code>$s1</code>写成<code>$1</code>；<br>寄存器对应错误（注意自己每个寄存器保存什么变量以及注意提示C代码中的变量与实际程序中的变量可能有区别）</li>
</ol>
<h2 id="P2教程"><a href="#P2教程" class="headerlink" title="P2教程"></a>P2教程</h2><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>考察循环使用，就是多个循环实现读取和计算</p>
<h3 id="回文串判断"><a href="#回文串判断" class="headerlink" title="回文串判断"></a>回文串判断</h3><p>简单的c程序翻译就好，需要注意的是利用$v0 &#x3D; 12来读入字符（$v0 &#x3D; 8会读入行尾换行符，不知道为啥，就这样吧）</p>
<h3 id="卷积运算"><a href="#卷积运算" class="headerlink" title="卷积运算"></a>卷积运算</h3><p>矩阵乘法plus版，临时寄存器的使用有点多，注意勿混</p>
<h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>先上C代码  </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P2/%E5%85%A8%E6%8E%92%E5%88%97c.jpg"
                      alt="1"
                ><br><strong>注意</strong> 递归调用一定要保护好递归前后的变量!!!</p>
<div class="highlight-container" data-rel="Mips"><figure class="iseeu highlight mips"><table><tr><td class="code"><pre><span class="line">   #</span><br><span class="line">   push($<span class="built_in">ra</span>) <span class="comment"># can also at the beginning</span></span><br><span class="line">   push($<span class="built_in">a1</span>)</span><br><span class="line">   push($<span class="built_in">t0</span>)</span><br><span class="line">   <span class="keyword">addi </span>$<span class="built_in">a1</span>,$<span class="built_in">a1</span>,<span class="number">1</span> <span class="comment"># index = index+1</span></span><br><span class="line">   <span class="keyword">jal </span>FullArray <span class="comment">###</span></span><br><span class="line">   pop($<span class="built_in">t0</span>)</span><br><span class="line">   pop($<span class="built_in">a1</span>)</span><br><span class="line">   pop($<span class="built_in">ra</span>) <span class="comment"># can also at the return</span></span><br><span class="line">   #</span><br><span class="line"><span class="symbol">return:</span></span><br><span class="line">   <span class="keyword">jr </span>$<span class="built_in">ra</span></span><br></pre></td></tr></table></figure></div>
<h3 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h3><ol>
<li>不确定是否要保护的寄存器，只要递归前后涉及改变就push和pop</li>
<li>注意递归前后某个数组变量的置0和置1</li>
</ol>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ol>
<li>多写注释，利用好宏</li>
<li>水仙花数，汉诺塔，约瑟夫环等等，多练习</li>
<li>认真认真！</li>
</ol>
<h1 id="P2上机加油！冲！"><a href="#P2上机加油！冲！" class="headerlink" title="P2上机加油！冲！"></a>P2上机加油！冲！</h1><h1 id="P2-Review"><a href="#P2-Review" class="headerlink" title="P2_Review"></a>P2_Review</h1><h2 id="匹配子串"><a href="#匹配子串" class="headerlink" title="匹配子串"></a>匹配子串</h2><ol>
<li>读取字符串  <div class="highlight-container" data-rel="Mips"><figure class="iseeu highlight mips"><table><tr><td class="code"><pre><span class="line">la $<span class="built_in">a0</span>,array <span class="comment"># the addr of the str</span></span><br><span class="line">li $<span class="built_in">a1</span>,<span class="number">200</span> <span class="comment"># the maxsize of the str is n-1</span></span><br><span class="line">li $<span class="built_in">v0</span>,<span class="number">8</span></span><br><span class="line"><span class="keyword">syscall</span></span><br></pre></td></tr></table></figure></div>
需要注意的是，这里的$a1存的是字符串的最长长度，读到\n停止<br>想要得到字符串的实际长度，需要手搓strlen  </li>
<li>判断是否匹配完子串，因为这里未知子串长度，所以用最后s2[j]是否为’\n’来判断比较好（但不知道为什么T了一个点，最后又设置了一个比较字符串上限的限制就过了）</li>
</ol>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ol>
<li>翻译c代码，没啥好说的</li>
<li>小错误：比如，$t5写成$5，$s3写成$a3等等</li>
<li>需要注意n可能为0，这里直接结束程序，示例c代码并没有给出相应处理，不过T的是第一个点，自己试一下也就知道了</li>
</ol>
<h1 id="P2结束啦！再接再厉！"><a href="#P2结束啦！再接再厉！" class="headerlink" title="P2结束啦！再接再厉！"></a>P2结束啦！再接再厉！</h1>]]></content>
      <categories>
        <category>BUAA_CO</category>
      </categories>
      <tags>
        <tag>BUAA_CO</tag>
      </tags>
  </entry>
  <entry>
    <title>P4</title>
    <url>/2023/01/02/P4/</url>
    <content><![CDATA[<h1 id="P4-Study"><a href="#P4-Study" class="headerlink" title="P4_Study"></a>P4_Study</h1><h1 id="1-单周期CPU设计方案（Verilog实现）"><a href="#1-单周期CPU设计方案（Verilog实现）" class="headerlink" title="1 单周期CPU设计方案（Verilog实现）"></a>1 单周期CPU设计方案（Verilog实现）</h1><h2 id="1-1-设计概述"><a href="#1-1-设计概述" class="headerlink" title="1.1 设计概述"></a>1.1 设计概述</h2><p>本文所呈现的是利用Verilog实现的MIPS架构CPU，可以支持10条指令，含有PC、NPC、IM、GRF、ALU、DM、Controller、EXT、Branch模块。整体采用自下而上的设计思路。</p>
<h2 id="1-2-实现指令说明"><a href="#1-2-实现指令说明" class="headerlink" title="1.2 实现指令说明"></a>1.2 实现指令说明</h2><h3 id="1-2-1-R型指令"><a href="#1-2-1-R型指令" class="headerlink" title="1.2.1 R型指令"></a>1.2.1 R型指令</h3><p>算术指令：add(暂视为不做溢出检查)，sub（暂视为不做溢出检查）<br>跳转指令：jr</p>
<h3 id="1-2-2-I型指令"><a href="#1-2-2-I型指令" class="headerlink" title="1.2.2 I型指令"></a>1.2.2 I型指令</h3><p>B类指令：beq<br>算术指令：lui，ori<br>访存指令：lw，sw</p>
<h3 id="1-2-3-J型指令"><a href="#1-2-3-J型指令" class="headerlink" title="1.2.3 J型指令"></a>1.2.3 J型指令</h3><p>跳转指令：jal</p>
<h3 id="1-2-4-其他"><a href="#1-2-4-其他" class="headerlink" title="1.2.4 其他"></a>1.2.4 其他</h3><p>nop</p>
<h2 id="1-3-数据通路模块定义"><a href="#1-3-数据通路模块定义" class="headerlink" title="1.3 数据通路模块定义"></a>1.3 数据通路模块定义</h2><h3 id="1-3-1-PC"><a href="#1-3-1-PC" class="headerlink" title="1.3.1 PC"></a>1.3.1 PC</h3><p>该模块包含一个32位寄存器用于存储当前执行的指令地址，考虑到可综合性，不用添加initial模块，通过tb里的reset来实现initial。<br><strong>注意：</strong> 指令地址从0x0000_3000开始</p>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
</tr>
<tr>
<td>NPC</td>
<td>I</td>
<td>32</td>
<td>下一条指令地址</td>
</tr>
<tr>
<td>PC</td>
<td>O</td>
<td>32</td>
<td>当前指令地址</td>
</tr>
</tbody></table>
</li>
<li>功能定义<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>同步复位</td>
<td>时钟上升沿到来时，如果reset信号有效，地址置为0x0000_3000</td>
</tr>
<tr>
<td>2</td>
<td>写入NPC</td>
<td>将下一条指令地址NPC写入寄存器</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="1-3-2-NPC"><a href="#1-3-2-NPC" class="headerlink" title="1.3.2 NPC"></a>1.3.2 NPC</h3><p>该模块为逻辑运算，通过选择信号和当前指令计算出下一条指令地址</p>
<ul>
<li>端口定义  <table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>pc</td>
<td>I</td>
<td>32</td>
<td>当前指令地址</td>
</tr>
<tr>
<td>imm16</td>
<td>I</td>
<td>16</td>
<td>instr[15:0]</td>
</tr>
<tr>
<td>imm26</td>
<td>I</td>
<td>26</td>
<td>instr[25:0]</td>
</tr>
<tr>
<td>ra</td>
<td>I</td>
<td>32</td>
<td>GPR[ra] (也可以是其他寄存器的内容)</td>
</tr>
<tr>
<td>PCCtrl</td>
<td>I</td>
<td>1</td>
<td>0 ：选择pc+4 <br> 1 ：选择beq所对应的npc</td>
</tr>
<tr>
<td>Jump</td>
<td>I</td>
<td>1</td>
<td>0:不是jr&#x2F;jal指令 <br> 1:是jr&#x2F;jal指令</td>
</tr>
<tr>
<td>jr</td>
<td>I</td>
<td>1</td>
<td>0：不是jr指令 <br> 1:是jr指令</td>
</tr>
</tbody></table>
</li>
<li>B类与J类指令实现机制<br>通过mux实现对npc的输出选择<br><strong>注意：</strong><br>弄清楚mux的0、1对应</li>
</ul>
<h3 id="1-3-3-IM"><a href="#1-3-3-IM" class="headerlink" title="1.3.3 IM"></a>1.3.3 IM</h3><p>该模块为指令存储单元，大小为4096*32 bits<br><strong>注意：</strong>  </p>
<ol>
<li>ROM为只读存储器，reset时其中数据不清零</li>
<li>pc默认是从0x0000_3000开始，故使用pc在ROM中索引相应指令时应为<code>temp = pc - 32&#39;h0000_3000</code></li>
<li>ROM容量为2^12，故<code>addr = temp[13:2]</code></li>
<li>利用系统调用函数读取指令信息<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$readmemh</span>(<span class="string">&quot;code.txt&quot;</span>,rom);</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
</tr>
<tr>
<td>pc</td>
<td>I</td>
<td>32</td>
<td>当前指令地址</td>
</tr>
<tr>
<td>opcode</td>
<td>O</td>
<td>6</td>
<td>instr[31：26]</td>
</tr>
<tr>
<td>func</td>
<td>O</td>
<td>6</td>
<td>instr[5:0]</td>
</tr>
<tr>
<td>rs</td>
<td>O</td>
<td>6</td>
<td>instr[25:21]</td>
</tr>
<tr>
<td>rt</td>
<td>O</td>
<td>6</td>
<td>instr[20:16]</td>
</tr>
<tr>
<td>rd</td>
<td>O</td>
<td>6</td>
<td>instr[15:11]</td>
</tr>
<tr>
<td>imm16</td>
<td>O</td>
<td>16</td>
<td>imm16[15:0]</td>
</tr>
<tr>
<td>imm26</td>
<td>O</td>
<td>26</td>
<td>imm26[25:0]</td>
</tr>
</tbody></table>
</li>
<li>功能定义<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>取指令</td>
<td>根据pc在ROM中取出相应指令</td>
</tr>
<tr>
<td>2</td>
<td>取数据</td>
<td>splitter行为，取出instr不同位所拥有的信息</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="1-3-4-GRF"><a href="#1-3-4-GRF" class="headerlink" title="1.3.4 GRF"></a>1.3.4 GRF</h3><p>该模块包含32个32位寄存器，对应MIPS架构中$0~$31通用寄存器，可以通过输入的5位地址访存寄存器，其中，$0寄存器设置写入信息为const0。</p>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
</tr>
<tr>
<td>A1</td>
<td>I</td>
<td>5</td>
<td>需要读取的第一个寄存器编号</td>
</tr>
<tr>
<td>A2</td>
<td>I</td>
<td>5</td>
<td>需要读取的第二个寄存器编号</td>
</tr>
<tr>
<td>A3</td>
<td>I</td>
<td>5</td>
<td>需要写入的寄存器编号</td>
</tr>
<tr>
<td>pc</td>
<td>I</td>
<td>32</td>
<td>当前指令的地址</td>
</tr>
<tr>
<td>Data</td>
<td>I</td>
<td>32</td>
<td>需要写入的数据</td>
</tr>
<tr>
<td>RegWrite</td>
<td>I</td>
<td>1</td>
<td>写使能信号</td>
</tr>
<tr>
<td>RD1</td>
<td>O</td>
<td>32</td>
<td>读取的第一个寄存器数据</td>
</tr>
<tr>
<td>RD2</td>
<td>O</td>
<td>32</td>
<td>读取的第二个寄存器数据</td>
</tr>
</tbody></table>
</li>
<li>功能定义<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>同步复位</td>
<td>当时钟上升沿到来，若reset信号有效，寄存器全部置0</td>
</tr>
<tr>
<td>2</td>
<td>读取寄存器</td>
<td>根据寄存器编号读取寄存器内容</td>
</tr>
<tr>
<td>3</td>
<td>写寄存器</td>
<td>根据寄存器编号、写使能信号、写入数据，向相应寄存器写入数据</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="1-3-5-ALU"><a href="#1-3-5-ALU" class="headerlink" title="1.3.5 ALU"></a>1.3.5 ALU</h3><p>该模块通过计算控制信号aluCtrl实现计算</p>
<ul>
<li>端口说明<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SourceA</td>
<td>I</td>
<td>32</td>
<td>第一个操作数</td>
</tr>
<tr>
<td>SourceB</td>
<td>I</td>
<td>32</td>
<td>第二个操作数</td>
</tr>
<tr>
<td>aluCtrl</td>
<td>I</td>
<td>3</td>
<td>计算控制信号<br>000:与 001：或 <br>010:加 110：减</td>
</tr>
<tr>
<td>ALUResult</td>
<td>O</td>
<td>32</td>
<td>计算结果</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="1-3-6-DM"><a href="#1-3-6-DM" class="headerlink" title="1.3.6 DM"></a>1.3.6 DM</h3><p>该模块为数据存储单元，大小为3072*32 bits</p>
<ul>
<li>端口说明<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
</tr>
<tr>
<td>pc</td>
<td>I</td>
<td>32</td>
<td>当前指令地址</td>
</tr>
<tr>
<td>Addr</td>
<td>I</td>
<td>32</td>
<td>需要读取&#x2F;写入的地址</td>
</tr>
<tr>
<td>WD</td>
<td>I</td>
<td>32</td>
<td>需要写入的数据</td>
</tr>
<tr>
<td>ReadData</td>
<td>O</td>
<td>32</td>
<td>从相应地址读取的数据</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="1-3-7-EXT"><a href="#1-3-7-EXT" class="headerlink" title="1.3.7 EXT"></a>1.3.7 EXT</h3><p>该模块通过位扩展信号对imm16进行位扩展<br><strong>注意：</strong>位拼接符的使用<code>&#123;&#123;16&#123;imm16[15]&#125;&#125;,imm16&#125;</code>,16外也有大括号，大括号的对应不要出错</p>
<ul>
<li>端口说明<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>imm16</td>
<td>I</td>
<td>16</td>
<td>instr[15:0]</td>
</tr>
<tr>
<td>EXTControl</td>
<td>I</td>
<td>2</td>
<td>控制以何种方式位扩展</td>
</tr>
<tr>
<td>immExtend</td>
<td>O</td>
<td>32</td>
<td>扩展后的结果</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="1-3-8-Branch"><a href="#1-3-8-Branch" class="headerlink" title="1.3.8 Branch"></a>1.3.8 Branch</h3><p>该模块输出控制信号PCSource，决定是否实现B类指令的跳转</p>
<ul>
<li>端口说明<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>If_branch</td>
<td>I</td>
<td>1</td>
<td>当前是否是B类指令</td>
</tr>
<tr>
<td>ALUResult</td>
<td>I</td>
<td>32</td>
<td>ALU的计算结果</td>
</tr>
<tr>
<td>PCSource</td>
<td>O</td>
<td>1</td>
<td>是否实现B类指令跳转</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="1-4-控制模块定义"><a href="#1-4-控制模块定义" class="headerlink" title="1.4 控制模块定义"></a>1.4 控制模块定义</h2><h3 id="1-4-1-Controller"><a href="#1-4-1-Controller" class="headerlink" title="1.4.1 Controller"></a>1.4.1 Controller</h3><p>该模块通过解码opcode和func来输出数据通路中的控制信号，主要分为and逻辑与or逻辑<br><strong>拓展：</strong>在and逻辑中增加相应的指令信号，在or逻辑中将需要置1的信号或上该指令信号。</p>
<ul>
<li>端口说明<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>opcode</td>
<td>I</td>
<td>6</td>
<td>instr[31:26]</td>
</tr>
<tr>
<td>func</td>
<td>I</td>
<td>6</td>
<td>instr[5:0]</td>
</tr>
<tr>
<td>Jump</td>
<td>O</td>
<td>1</td>
<td>是否J型指令</td>
</tr>
<tr>
<td>jr</td>
<td>O</td>
<td>1</td>
<td>是否为jr指令</td>
</tr>
<tr>
<td>RegDst</td>
<td>O</td>
<td>1</td>
<td>0：rt <br> 1: rd</td>
</tr>
<tr>
<td>raLink</td>
<td>O</td>
<td>1</td>
<td>0: rt&#x2F;rd <br> 1: ra(31)</td>
</tr>
<tr>
<td>aluSource</td>
<td>O</td>
<td>1</td>
<td>0: RD2 <br> 1: immExtend</td>
</tr>
<tr>
<td>Branch</td>
<td>O</td>
<td>1</td>
<td>当前是否为B类指令</td>
</tr>
<tr>
<td>MemtoReg</td>
<td>O</td>
<td>1</td>
<td>0：ALUResult <br> 1:ReadData</td>
</tr>
<tr>
<td>AddrTrans</td>
<td>O</td>
<td>1</td>
<td>0: A&#x2F;R <br> 1:pc+4</td>
</tr>
<tr>
<td>RegWrite</td>
<td>O</td>
<td>1</td>
<td>GRF写使能信号</td>
</tr>
<tr>
<td>MemWrite</td>
<td>O</td>
<td>1</td>
<td>DM写使能信号</td>
</tr>
<tr>
<td>EXTCtrl</td>
<td>O</td>
<td>2</td>
<td>位扩展控制信号</td>
</tr>
<tr>
<td>aluCtrl</td>
<td>O</td>
<td>3</td>
<td>ALU控制信号</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="1-4-2-MUX"><a href="#1-4-2-MUX" class="headerlink" title="1.4.2 MUX"></a>1.4.2 MUX</h3><p>多个MUX模块放在同一个mux.v文件中。其实可以不写mux.v文件，遇到多路选择器可以直接用三目语句而不用示例化一个MUX。<br><strong>注意：</strong> 0,1一定要对应好！！！<br>mux_mforn</p>
<ul>
<li>端口说明<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>I</td>
<td>n</td>
<td>选择数据1</td>
</tr>
<tr>
<td>B</td>
<td>I</td>
<td>n</td>
<td>选择数据2</td>
</tr>
<tr>
<td>sel</td>
<td>I</td>
<td>1</td>
<td>选择信号</td>
</tr>
<tr>
<td>result</td>
<td>O</td>
<td>n</td>
<td>输出结果</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="2-测试方案"><a href="#2-测试方案" class="headerlink" title="2 测试方案"></a>2 测试方案</h1><h2 id="2-1-测试数据"><a href="#2-1-测试数据" class="headerlink" title="2.1 测试数据"></a>2.1 测试数据</h2><p>通过比较大的测试数据和与同学对拍进行测试。</p>
<div class="highlight-container" data-rel="Mips"><figure class="iseeu highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lui </span>$<span class="number">1</span>,<span class="number">0x64a1</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">1</span>,$<span class="number">1</span>,<span class="number">0x1ff8</span></span><br><span class="line"><span class="keyword">lui </span>$<span class="number">2</span>,<span class="number">0x5f21</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">2</span>,$<span class="number">2</span>,<span class="number">0x5205</span></span><br><span class="line"><span class="keyword">lui </span>$<span class="number">3</span>,<span class="number">0x1c6b</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">3</span>,$<span class="number">3</span>,<span class="number">0x7773</span></span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="comment"># 见testinstr.txt</span></span><br></pre></td></tr></table></figure></div>
<p>机器码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">3c0164a1</span><br><span class="line">34211ff8</span><br><span class="line">3c025f21</span><br><span class="line">34425205</span><br><span class="line">3c031c6b</span><br><span class="line">34637773</span><br><span class="line">// ......</span><br><span class="line">// 见testcode_hex.txt</span><br></pre></td></tr></table></figure></div>
<h1 id="3-可能的拓展"><a href="#3-可能的拓展" class="headerlink" title="3 可能的拓展"></a>3 可能的拓展</h1><h2 id="3-1-draft"><a href="#3-1-draft" class="headerlink" title="3.1 draft"></a>3.1 draft</h2><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lw/lh/lhu/lb/lbu</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] temp = DM[Addr[<span class="number">11</span>:<span class="number">2</span>]] ;</span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(LoadOp)</span><br><span class="line">            `LS_LW: RD = temp;</span><br><span class="line">            `LS_LH: RD = (Addr[<span class="number">1</span>] == <span class="number">1&#x27;b0</span>) ? &#123;&#123;<span class="number">16</span>&#123;temp[<span class="number">15</span>]&#125;&#125;,temp[<span class="number">15</span>:<span class="number">0</span>]&#125; :</span><br><span class="line">                                &#123;&#123;<span class="number">16</span>&#123;temp[<span class="number">31</span>]&#125;&#125;,temp[<span class="number">31</span>:<span class="number">16</span>]&#125;;</span><br><span class="line">            `LS_LHU: RD = (Addr[<span class="number">1</span>] == <span class="number">1&#x27;b0</span>) ? &#123;&#123;<span class="number">16</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;,temp[<span class="number">15</span>:<span class="number">0</span>]&#125; :</span><br><span class="line">                                &#123;&#123;<span class="number">16</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;,temp[<span class="number">31</span>:<span class="number">16</span>]&#125;;</span><br><span class="line">            `LS_LB: RD = (Addr[<span class="number">1</span>:<span class="number">0</span>] == <span class="number">2&#x27;b00</span>) ? &#123;&#123;<span class="number">24</span>&#123;temp[<span class="number">7</span>]&#125;&#125;,temp[<span class="number">7</span>:<span class="number">0</span>]&#125; :</span><br><span class="line">                                (Addr[<span class="number">1</span>:<span class="number">0</span>] == <span class="number">2&#x27;b01</span>) ? &#123;&#123;<span class="number">24</span>&#123;temp[<span class="number">15</span>]&#125;&#125;,temp[<span class="number">15</span>:<span class="number">8</span>]&#125; :</span><br><span class="line">                                (Addr[<span class="number">1</span>:<span class="number">0</span>] == <span class="number">2&#x27;b10</span>) ? &#123;&#123;<span class="number">24</span>&#123;temp[<span class="number">23</span>]&#125;&#125;,temp[<span class="number">23</span>:<span class="number">16</span>]&#125; :</span><br><span class="line">                                &#123;&#123;<span class="number">24</span>&#123;temp[<span class="number">31</span>]&#125;&#125;,temp[<span class="number">31</span>:<span class="number">24</span>]&#125;;</span><br><span class="line">            `LS_LBU: RD = (Addr[<span class="number">1</span>:<span class="number">0</span>] == <span class="number">2&#x27;b00</span>) ? &#123;&#123;<span class="number">24</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;,temp[<span class="number">7</span>:<span class="number">0</span>]&#125;:</span><br><span class="line">                                 (Addr[<span class="number">1</span>:<span class="number">0</span>] == <span class="number">2&#x27;b01</span>) ? &#123;&#123;<span class="number">24</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;,temp[<span class="number">15</span>:<span class="number">8</span>]&#125;:</span><br><span class="line">                                 (Addr[<span class="number">1</span>:<span class="number">0</span>] == <span class="number">2&#x27;b10</span>) ? &#123;&#123;<span class="number">24</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;,temp[<span class="number">23</span>:<span class="number">16</span>]&#125;:</span><br><span class="line">                                 &#123;&#123;<span class="number">24</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;,temp[<span class="number">31</span>:<span class="number">24</span>]&#125;;</span><br><span class="line">            <span class="keyword">default</span>: RD = temp;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sw/sh/sb</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk ) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3072</span>; i = i + <span class="number">1</span>)<span class="keyword">begin</span></span><br><span class="line">            DM[i] = <span class="number">32&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(MemWrite == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(StoreOp)</span><br><span class="line">            `LS_SW: DM[Addr[<span class="number">11</span>:<span class="number">2</span>]] &lt;= WD;</span><br><span class="line">            `LS_SH: DM[Addr[<span class="number">11</span>:<span class="number">2</span>]] &lt;=</span><br><span class="line">            (Addr[<span class="number">1</span>] == <span class="number">1&#x27;b0</span>) ? &#123;temp[<span class="number">31</span>:<span class="number">16</span>],WD[<span class="number">15</span>:<span class="number">0</span>]&#125; :</span><br><span class="line">            &#123;WD[<span class="number">15</span>:<span class="number">0</span>],temp[<span class="number">15</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">            `LS_SB: DM[Addr[<span class="number">11</span>:<span class="number">2</span>]] &lt;=</span><br><span class="line">            (Addr[<span class="number">1</span>:<span class="number">0</span>] == <span class="number">2&#x27;b00</span>) ? &#123;temp[<span class="number">31</span>:<span class="number">8</span>],WD[<span class="number">7</span>:<span class="number">0</span>]&#125; :</span><br><span class="line">            (Addr[<span class="number">1</span>:<span class="number">0</span>] == <span class="number">2&#x27;b01</span>) ? &#123;temp[<span class="number">31</span>:<span class="number">16</span>],WD[<span class="number">7</span>:<span class="number">0</span>],temp[<span class="number">7</span>:<span class="number">0</span>]&#125; :</span><br><span class="line">            (Addr[<span class="number">1</span>:<span class="number">0</span>] == <span class="number">2&#x27;b10</span>) ? &#123;temp[<span class="number">31</span>:<span class="number">24</span>],WD[<span class="number">7</span>:<span class="number">0</span>],temp[<span class="number">15</span>:<span class="number">0</span>]&#125; :</span><br><span class="line">            &#123;WD[<span class="number">7</span>:<span class="number">0</span>],temp[<span class="number">23</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">        <span class="keyword">default</span>: DM[Addr[<span class="number">11</span>:<span class="number">2</span>]] &lt;= DM[Addr[<span class="number">11</span>:<span class="number">2</span>]];</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">else</span> DM[Addr[<span class="number">11</span>:<span class="number">2</span>]] &lt;= DM[Addr[<span class="number">11</span>:<span class="number">2</span>]];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断data中的1个数是否为奇数</span></span><br><span class="line"><span class="comment">//某位往届学长做法，类似于VotePlus的做法</span></span><br><span class="line"><span class="keyword">wire</span> odd;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] num;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">integer</span> i;</span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    num = <span class="number">0</span>;<span class="comment">//每次计算的时候num需要清零</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(RegRead1[i] == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            num = num + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">assign</span> odd = num[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//我的想法（和奇偶校验做法一样）</span></span><br><span class="line"><span class="keyword">wire</span> odd;</span><br><span class="line"><span class="keyword">assign</span> odd = ^RegRead1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“字对齐”输出,即要求必须是4的倍数，而我们原来输出的都是byte的地址</span></span><br><span class="line">$display$display(<span class="string">&quot;@%h: *%h &lt;= %h&quot;</span>,pc,&#123;MemAddr[<span class="number">31</span>:<span class="number">2</span>],&#123;<span class="number">2</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;&#125;,WD);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断data后缀0个数</span></span><br><span class="line"><span class="comment">//while</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] num ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">integer</span> i;</span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    i = <span class="number">0</span>;<span class="comment">//initial</span></span><br><span class="line">    <span class="keyword">while</span> ((i &lt; <span class="number">32</span>) &amp;&amp; (RegRead1[i] == <span class="number">0</span>)) <span class="keyword">begin</span></span><br><span class="line">        num = num + <span class="number">1</span>;</span><br><span class="line">        i = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">//for</span></span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;(i &lt; <span class="number">32</span>) &amp;&amp; (RegRead1[i] == <span class="number">0</span>); i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        num = num + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h2 id="3-2-其他拓展思考"><a href="#3-2-其他拓展思考" class="headerlink" title="3.2 其他拓展思考"></a>3.2 其他拓展思考</h2><ol>
<li>主要修改ALU模块和Controller模块</li>
<li>对于半字&#x2F;字节读取等，在DM模块做出相应修改</li>
<li>读好RTL，列出信号的0，1情况，认真</li>
</ol>
<h1 id="4-思考题解答"><a href="#4-思考题解答" class="headerlink" title="4 思考题解答"></a>4 思考题解答</h1><ol>
<li>阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？<br>答：addr信号是上一个模块ALU计算出的ALUResult（当然根据每条指令RTL的不同，也可能是其他模块的输出结果）。因为DM是以字（32bits）为单位存储，而addr是以字节（8bits）为单位计数,因此2^12(Byte)&#x2F;2^2 &#x3D; 2^10,去掉addr的最低两位(表示字节)，取addr[11:2]。</li>
<li>思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指令对应的控制信号如何取值</span></span><br><span class="line"><span class="keyword">always</span> @(*) </span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (add) <span class="keyword">begin</span></span><br><span class="line">            RegDst = <span class="number">1</span>;</span><br><span class="line">            RegWrite = <span class="number">1</span>;</span><br><span class="line">            ALUCtrl = <span class="number">3&#x27;b010</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sub) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        <span class="keyword">end</span>   </span><br><span class="line">        <span class="comment">//......   </span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//控制信号所对应的指令</span></span><br><span class="line"><span class="keyword">assign</span> Jump = jal | jr;</span><br><span class="line"><span class="keyword">assign</span> RegDst = add | sub;</span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></table></figure></div>
第一种译码方式方便清楚每一个指令对应的控制信号，但书写代码量较大。第二种译码方式代码书写量较小，但需要注意的是，增加新的指令时，各种控制信号的增改勿重勿漏。</li>
<li>在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。<br>答：同步复位clk信号优先级更高，异步复位reset信号优先级更高。</li>
</ol>
<h1 id="祝P4上机一切顺利！"><a href="#祝P4上机一切顺利！" class="headerlink" title="祝P4上机一切顺利！"></a>祝P4上机一切顺利！</h1><h1 id="P4-review"><a href="#P4-review" class="headerlink" title="P4_review"></a>P4_review</h1><h2 id="写在前面：Verilog就是很容易出小问题"><a href="#写在前面：Verilog就是很容易出小问题" class="headerlink" title="写在前面：Verilog就是很容易出小问题"></a>写在前面：Verilog就是很容易出小问题</h2><ol>
<li>是否有符号数，注意<code>$signed</code></li>
<li>多加括号，勤加括号</li>
<li>判断条件写成<code>temp32 != temp32</code>,我是笨蛋</li>
<li>不要慌乱，把子模块的信号什么都加好</li>
<li>祝流水线顺利！</li>
</ol>
]]></content>
      <categories>
        <category>BUAA_CO</category>
      </categories>
      <tags>
        <tag>BUAA_CO</tag>
      </tags>
  </entry>
  <entry>
    <title>P3</title>
    <url>/2023/01/02/P3/</url>
    <content><![CDATA[<h1 id="P3-Study"><a href="#P3-Study" class="headerlink" title="P3_Study"></a>P3_Study</h1><h1 id="1-单周期CPU设计方案"><a href="#1-单周期CPU设计方案" class="headerlink" title="1 单周期CPU设计方案"></a>1 单周期CPU设计方案</h1><h2 id="1-1-设计概述"><a href="#1-1-设计概述" class="headerlink" title="1.1 设计概述"></a>1.1 设计概述</h2><p>本文所呈现的是利用logisim实现的MIPS架构CPU，可以支持8条指令，含有IFU、GRF、ALU、DM、Controller、BranchControl、EXT、NPC模块。整体设计实现采用自下而上的设计思路，先逐一设计搭建每个子模块，再将所有子模块整合连接，从而实现完整的数据通路。<br>CPU顶层模块如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/P3CPU%E9%A1%B6%E5%B1%82%E6%A8%A1%E5%9D%971.jpg"
                      alt="1"
                ></p>
<h2 id="1-2-实现指令说明"><a href="#1-2-实现指令说明" class="headerlink" title="1.2 实现指令说明"></a>1.2 实现指令说明</h2><h3 id="1-2-1-R型指令"><a href="#1-2-1-R型指令" class="headerlink" title="1.2.1 R型指令"></a>1.2.1 R型指令</h3><p>算术指令：add(暂视为不做溢出检查)，sub（暂视为不做溢出检查）<br>若要扩展支持其他R型指令，主要改变Controller模块与ALU模块  </p>
<h3 id="1-2-2-I型指令"><a href="#1-2-2-I型指令" class="headerlink" title="1.2.2 I型指令"></a>1.2.2 I型指令</h3><p>B类指令：beq<br>算术指令：lui，ori<br>访存指令：lw，sw<br>若要扩展支持其他I型指令，主要改变Controller模块，EXT模块，ALU模块</p>
<h3 id="1-2-3-J型指令"><a href="#1-2-3-J型指令" class="headerlink" title="1.2.3 J型指令"></a>1.2.3 J型指令</h3><p>本CPU不支持J型指令，若要支持j，jr等指令可做以下拓展：<br>①Controller模块增加JR与JUMP信号输出<br>②NPC模块增加JR与JUMP信号输入、将Imm16改为Imm26、增加GPR[ra]数据输入</p>
<h3 id="1-2-4-其他"><a href="#1-2-4-其他" class="headerlink" title="1.2.4 其他"></a>1.2.4 其他</h3><p>nop</p>
<h2 id="1-3-数据通路模块"><a href="#1-3-数据通路模块" class="headerlink" title="1.3 数据通路模块"></a>1.3 数据通路模块</h2><h3 id="1-3-1-IFU（取指令单元）"><a href="#1-3-1-IFU（取指令单元）" class="headerlink" title="1.3.1 IFU（取指令单元）"></a>1.3.1 IFU（取指令单元）</h3><p>该模块包含PC（程序计数器）和IM（指令存储器），PC通过32位寄存器实现，存储当前需执行指令的地址，IM通过ROM实现（32 * 32bit），存储所有需要执行的指令。根据PC的值从IM中取出对应指令传入后续数据通路。<br><strong>注意</strong> ：<br>ROM中是以字为单位存储的，并且ROM容量为32条指令，只需五位数表示地址，所以取PC的6<del>2位即可。同理，若ROM容量为1024*32bit则取PC的11</del>2位。  </p>
<ul>
<li>模块外观<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/IFU.jpg"
                      alt="1"
                >  </li>
<li>模块内部电路<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/IFU%E7%94%B5%E8%B7%AF.jpg"
                      alt="1"
                > </li>
<li>端口定义  <table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号</td>
</tr>
<tr>
<td>NPC</td>
<td>I</td>
<td>32</td>
<td>下一条要被执行的指令的地址</td>
</tr>
<tr>
<td>Imm</td>
<td>O</td>
<td>16</td>
<td>当前指令的15~0位</td>
</tr>
<tr>
<td>func</td>
<td>O</td>
<td>6</td>
<td>当前指令的5~0位</td>
</tr>
<tr>
<td>Opcode</td>
<td>O</td>
<td>6</td>
<td>当前指令的31~26位</td>
</tr>
<tr>
<td>Instr</td>
<td>O</td>
<td>32</td>
<td>当前执行的指令</td>
</tr>
<tr>
<td>rs</td>
<td>O</td>
<td>5</td>
<td>当前指令的25~21位</td>
</tr>
<tr>
<td>rt</td>
<td>O</td>
<td>5</td>
<td>当前指令的20~16位</td>
</tr>
<tr>
<td>rd</td>
<td>O</td>
<td>5</td>
<td>当前指令的15~11位</td>
</tr>
<tr>
<td>PC</td>
<td>O</td>
<td>32</td>
<td>当前指令的地址</td>
</tr>
</tbody></table>
</li>
<li>功能定义<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>复位</td>
<td>reset信号为1时，PC寄存器的值置为0x00000000</td>
</tr>
<tr>
<td>2</td>
<td>取指令</td>
<td>根据当前PC寄存器的值从ROM中读取指令</td>
</tr>
<tr>
<td>3</td>
<td>取数据</td>
<td>根据不同位代表不同信息读取指令包含的数据</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="1-3-2-GRF（通用寄存器组）"><a href="#1-3-2-GRF（通用寄存器组）" class="headerlink" title="1.3.2 GRF（通用寄存器组）"></a>1.3.2 GRF（通用寄存器组）</h3><p>该模块包含32个32位寄存器，对应MIPS架构中$0~$31通用寄存器，可以通过输入的5位地址访存寄存器，其中，$0寄存器设置写入信息为const0。  </p>
<ul>
<li>模块外观<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/GRF.jpg"
                      alt="1"
                ></li>
<li>模块内部电路<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/GRF%E7%94%B5%E8%B7%AF.jpg"
                      alt="1"
                ></li>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号</td>
</tr>
<tr>
<td>WE</td>
<td>I</td>
<td>1</td>
<td>写使能信号，决定当前寄存器堆是否可以写入</td>
</tr>
<tr>
<td>rs</td>
<td>I</td>
<td>5</td>
<td>需要读取的第1个寄存器的编号</td>
</tr>
<tr>
<td>rt</td>
<td>I</td>
<td>5</td>
<td>需要读取的第2个寄存器的编号</td>
</tr>
<tr>
<td>rd</td>
<td>I</td>
<td>5</td>
<td>需要写入的寄存器的编号</td>
</tr>
<tr>
<td>Data</td>
<td>I</td>
<td>32</td>
<td>需要写入寄存器的数据</td>
</tr>
<tr>
<td>RD1</td>
<td>O</td>
<td>32</td>
<td>读取到的第1个寄存器的数据</td>
</tr>
<tr>
<td>RD2</td>
<td>O</td>
<td>32</td>
<td>读取到的第2个寄存器的数据</td>
</tr>
</tbody></table>
</li>
<li>功能定义<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>复位</td>
<td>reset信号为1时，所有寄存器的值变为0</td>
</tr>
<tr>
<td>2</td>
<td>读取数据</td>
<td>将rs，rt地址对应寄存器的数据加载到RD1，RD2</td>
</tr>
<tr>
<td>3</td>
<td>写入数据</td>
<td>WE信号为1且时钟上升沿到来时，将Data中数据写入rd地址对应的寄存器</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="1-3-3-ALU（算术运算单元）"><a href="#1-3-3-ALU（算术运算单元）" class="headerlink" title="1.3.3 ALU（算术运算单元）"></a>1.3.3 ALU（算术运算单元）</h3><p>该模块可以实现加、减、与、或运算，通过ALUOp信号选择何种运算，通过logisim内置算术运算与逻辑运算原件实现运算。</p>
<ul>
<li>模块外观<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/ALU.jpg"
                      alt="1"
                ></li>
<li>模块内部电路<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/ALU%E7%94%B5%E8%B7%AF.jpg"
                      alt="1"
                ></li>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ALUControl</td>
<td>I</td>
<td>3</td>
<td>ALU功能选择信号</td>
</tr>
<tr>
<td>SourceA</td>
<td>I</td>
<td>32</td>
<td>参与ALU计算的第一个数据</td>
</tr>
<tr>
<td>SourceB</td>
<td>I</td>
<td>32</td>
<td>参与ALU计算的第二个数据</td>
</tr>
<tr>
<td>ALUResult</td>
<td>O</td>
<td>32</td>
<td>ALU计算结果</td>
</tr>
</tbody></table>
</li>
<li>功能定义<br>|序号|功能名称|ALUOp|功能描述|<br>|1|按位与|000|ALUResult &#x3D; SourceA &amp; SourceB|<br>|2|按位或|001|ALUResult &#x3D; SourceA | SourceB|<br>|3|加|010|ALUResult &#x3D; SourceA + SourceB|<br>|4|减|110|ALUResult &#x3D; SourceA - SourceB|</li>
<li>可能的拓展：</li>
</ul>
<ol>
<li>移位指令sll，srl，sra：<br>  增加ALU模块的shift数据输入，利用logisim内置移位器实现移位；增加ALU模块中ALUOp的对应信号</li>
<li>add、sub溢出判断：<br>  增加ALU模块FlowJudge信号输入，指示是否需要判断溢出，通过比较temp32与temp31是否相等判断是否溢出，增加ALU模块Overflow信号输出，输出是否溢出</li>
</ol>
<h3 id="1-3-4-DM（数据存储器）"><a href="#1-3-4-DM（数据存储器）" class="headerlink" title="1.3.4 DM（数据存储器）"></a>1.3.4 DM（数据存储器）</h3><p>该模块利用RAM元件实现对数据的访存<br><strong>注意</strong>：<br>①RAM要设置separate load and store ports<br>②RAM写使能端不可浮空，否则会随机写入</p>
<ul>
<li>模块外观<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/DM.jpg"
                      alt="1"
                ></li>
<li>模块内部电路<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/DM%E7%94%B5%E8%B7%AF.jpg"
                      alt="1"
                ></li>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号</td>
</tr>
<tr>
<td>WE</td>
<td>I</td>
<td>1</td>
<td>写使能信号，决定当前RAM是否可以写入</td>
</tr>
<tr>
<td>ALUResult</td>
<td>I</td>
<td>32</td>
<td>需要访存的地址，指向RAM中的某个存储单元</td>
</tr>
<tr>
<td>WriteData</td>
<td>I</td>
<td>32</td>
<td>需要写入的数据</td>
</tr>
<tr>
<td>ReadData</td>
<td>O</td>
<td>32</td>
<td>从RAM中读取到的数据</td>
</tr>
</tbody></table>
</li>
<li>功能定义<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>复位</td>
<td>reset信号有效时，RAM中的数据将被清零</td>
</tr>
<tr>
<td>2</td>
<td>读取数据</td>
<td>读取ALUResult地址对应存储单元的数据，将其加载到ReadData</td>
</tr>
<tr>
<td>3</td>
<td>写入数据</td>
<td>当WE信号有效且时钟上升沿到来，将WriteData写入ALUResult对应的存储单元</td>
</tr>
</tbody></table>
</li>
<li>可能的拓展<br>对于lb，lbu，lh，lhu，sb，sh等对字节或者半字进行访存操作的指令，可以设置一个另一个子模块LSControl。首先根据ALUResult将RAM中的对应数据ReadData读取&#x2F;由WriteData输入数据，然后把32位数据输入LSControl处理，得到真正需要读取的数据LoadData或写入数据StoreData，然后通过mux实现真正数据的读取和写入。</li>
</ul>
<h3 id="1-3-5-Controller（控制器）"><a href="#1-3-5-Controller（控制器）" class="headerlink" title="1.3.5 Controller（控制器）"></a>1.3.5 Controller（控制器）</h3><p>通过解码Opcode（31<del>25）和func（5</del>0）以及Instr整体，输出当前指令对应的控制信号。主要组成是AND逻辑——当前是和指令；OR逻辑——当前指令对应的信号输出。</p>
<ul>
<li>模块外观<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/Controller1%E5%A4%96%E8%A7%82.jpg"
                      alt="1"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/Controller1appearance.jpg"
                      alt="1"
                ></li>
<li>模块内部电路<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/Controller1.jpg"
                      alt="1"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/Controller1%E7%94%B5%E8%B7%AF.jpg"
                      alt="1"
                ></li>
<li>端口定义<table>
<thead>
<tr>
<th>信号</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
<th>触发信号</th>
</tr>
</thead>
<tbody><tr>
<td>Opcode</td>
<td>I</td>
<td>6</td>
<td>指令的31~26位</td>
<td></td>
</tr>
<tr>
<td>func</td>
<td>I</td>
<td>6</td>
<td>指令的5~0位，确定是何种R型指令，I型和J型指令不必要判断</td>
<td>add，sub</td>
</tr>
<tr>
<td>Instr</td>
<td>I</td>
<td>32</td>
<td>整条指令，这里主要是判断是否为nop指令</td>
<td></td>
</tr>
<tr>
<td>RegDst</td>
<td>O</td>
<td>1</td>
<td>0：寄存器堆写入寄存器为rt（20<del>16）  1：寄存器堆写入寄存器为rd（15</del>11）</td>
<td>add，sub</td>
</tr>
<tr>
<td>RegWrite</td>
<td>O</td>
<td>1</td>
<td>0:寄存器堆不可写入  1：寄存器堆写入使能</td>
<td>add，sub，ori，lw，lui</td>
</tr>
<tr>
<td>MemtoReg</td>
<td>O</td>
<td>1</td>
<td>0:ALUResult写入寄存器堆  1：ReadData写入寄存器堆</td>
<td>lw</td>
</tr>
<tr>
<td>ALUSource</td>
<td>O</td>
<td>1</td>
<td>0：ALU的SourceB是RD2  1：ALU的SourceB是ImmExtend</td>
<td>ori，lw，sw，lui</td>
</tr>
<tr>
<td>MemWrite</td>
<td>O</td>
<td>1</td>
<td>0：DM不可写入  1：DM可以写入</td>
<td>sw</td>
</tr>
<tr>
<td>Branch</td>
<td>O</td>
<td>1</td>
<td>0：是Beq指令 1：不是Beq指令</td>
<td>beq</td>
</tr>
<tr>
<td>EXTCtrl</td>
<td>O</td>
<td>2</td>
<td>00：符号拓展 01：零拓展 10：将imm16左移16位 11：sign_extend(imm16 + 00)</td>
<td>ori，lw，sw，beq，lui</td>
</tr>
<tr>
<td>ALUCtrl</td>
<td>O</td>
<td>3</td>
<td>控制ALU进行何种运算的信号</td>
<td>add，sub，ori，lw，sw，beq，lui</td>
</tr>
</tbody></table>
</li>
<li>功能定义<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>输出控制信号</td>
<td>根据Opcode和func输出控制整个数据通路的信号</td>
</tr>
</tbody></table>
</li>
<li>可能的拓展<br>跟据不同的指令要求，输出所需要的控制信号</li>
</ul>
<h3 id="1-3-6-BranchControl（B类指令控制模块）"><a href="#1-3-6-BranchControl（B类指令控制模块）" class="headerlink" title="1.3.6 BranchControl（B类指令控制模块）"></a>1.3.6 BranchControl（B类指令控制模块）</h3><p>该模块主要用于处理B类指令是否跳转，B类指令可以跳转有两个条件：①是B类指令②满足跳转要求</p>
<ul>
<li>模块外观<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/BranchControl.jpg"
                      alt="1"
                ></li>
<li>模块内部电路<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/BranchControl%E7%94%B5%E8%B7%AF.jpg"
                      alt="1"
                ></li>
<li>端口定义<table>
<thead>
<tr>
<th>信号</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ALUResult</td>
<td>I</td>
<td>1</td>
<td>判断是否为0、不为0、大于0等等，从而去匹配B类指令的跳转条件</td>
</tr>
<tr>
<td>Branch</td>
<td>I</td>
<td>1</td>
<td>当前指令是否是B类指令</td>
</tr>
<tr>
<td>PCSource</td>
<td>O</td>
<td>1</td>
<td>控制信号，控制NPC是（PC+4）或者B类信号跳转到的PC值</td>
</tr>
</tbody></table>
</li>
<li>功能定义<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>PC跳转信号输出</td>
<td>决定NPC是否是B类指令跳转到的PC值</td>
</tr>
</tbody></table>
</li>
<li>可能的拓展<br>①需要增加BranchOp信号输入，判断当前是何种B类指令<br>②对于bltz，blez，bgtz，bgez等指令，增加32位操作数输入，直接与0比较判断即可。<br>最终PCSource信号输出由mux和与门合力完成。</li>
</ul>
<h3 id="1-3-7-EXT（扩展单元）"><a href="#1-3-7-EXT（扩展单元）" class="headerlink" title="1.3.7 EXT（扩展单元）"></a>1.3.7 EXT（扩展单元）</h3><p>本模块根据不同指令对立即数的扩展需要对立即数进行扩展</p>
<ul>
<li>模块外观<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/EXT.jpg"
                      alt="1"
                ></li>
<li>模块内部电路<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/EXT%E7%94%B5%E8%B7%AF.jpg"
                      alt="1"
                ></li>
<li>端口定义<table>
<thead>
<tr>
<th>信号</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Imm</td>
<td>I</td>
<td>16</td>
<td>需扩展的立即数</td>
</tr>
<tr>
<td>EXTControl</td>
<td>I</td>
<td>2</td>
<td>控制进行何种扩展</td>
</tr>
<tr>
<td>ImmExtend</td>
<td>O</td>
<td>16</td>
<td>扩展结果</td>
</tr>
</tbody></table>
</li>
<li>功能定义<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>立即数扩展</td>
<td>把立即数进行相应拓展</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="1-3-8-NPC（计算下一条指令的地址）"><a href="#1-3-8-NPC（计算下一条指令的地址）" class="headerlink" title="1.3.8 NPC（计算下一条指令的地址）"></a>1.3.8 NPC（计算下一条指令的地址）</h3><p>该模块用于计算下一条需要执行的指令的地址</p>
<ul>
<li>模块外观<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/NPC.jpg"
                      alt="1"
                ></li>
<li>模块内部电路<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/NPC%E7%94%B5%E8%B7%AF.jpg"
                      alt="1"
                ></li>
<li>端口定义<table>
<thead>
<tr>
<th>信号</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PC</td>
<td>I</td>
<td>32</td>
<td>当前指令地址</td>
</tr>
<tr>
<td>Imm</td>
<td>I</td>
<td>16</td>
<td>当前指令的15~0位</td>
</tr>
<tr>
<td>PCSource</td>
<td>I</td>
<td>1</td>
<td>0：PC+4 1：B类指令跳转地址</td>
</tr>
<tr>
<td>NPC</td>
<td>O</td>
<td>32</td>
<td>下一条指令地址</td>
</tr>
</tbody></table>
</li>
<li>功能定义<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>计算NPC</td>
<td>根据当前指令计算NPC</td>
</tr>
</tbody></table>
</li>
<li>可能的拓展<br>主要是对于J类指令的拓展<br>对于J需要增加指令25~0位输入，对于jal还需增加PC+4输出，对于jr指令需增加$ra的数据输入。然后利用splitter和mux实现最终的NPC输出。</li>
</ul>
<h1 id="2-测试方案"><a href="#2-测试方案" class="headerlink" title="2 测试方案"></a>2 测试方案</h1><h2 id="2-1-典型测试样例"><a href="#2-1-典型测试样例" class="headerlink" title="2.1 典型测试样例"></a>2.1 典型测试样例</h2><div class="highlight-container" data-rel="Mips"><figure class="iseeu highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 算术指令</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="built_in">a0</span>, $<span class="number">0</span>, <span class="number">123</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="built_in">a1</span>, $<span class="built_in">a0</span>, <span class="number">456</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="built_in">a2</span>,$<span class="built_in">a1</span>,<span class="number">65534</span></span><br><span class="line"><span class="keyword">lui </span>$<span class="built_in">a3</span>, <span class="number">123</span>            </span><br><span class="line"><span class="keyword">lui </span>$<span class="built_in">t4</span>, <span class="number">0xffff</span></span><br><span class="line"><span class="keyword">lui </span>$<span class="built_in">t1</span>,<span class="number">42528</span>         </span><br><span class="line"><span class="keyword">ori </span>$<span class="built_in">a3</span>, $<span class="built_in">a3</span>, <span class="number">0xffff</span>    </span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">s0</span>, $<span class="built_in">a0</span>, $<span class="built_in">a2</span>      </span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">s1</span>, $<span class="built_in">a0</span>, $<span class="built_in">a3</span>      </span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">s2</span>, $<span class="built_in">a3</span>, $<span class="built_in">a3</span></span><br><span class="line"><span class="keyword">sub </span>$<span class="built_in">t2</span>,$<span class="built_in">t1</span>,$<span class="built_in">a0</span></span><br><span class="line"><span class="keyword">sub </span>$<span class="built_in">t3</span>,$<span class="built_in">t2</span>,$<span class="built_in">a2</span>      </span><br><span class="line"><span class="keyword">ori </span>$<span class="built_in">t0</span>, $<span class="number">0</span>, <span class="number">0x0000</span></span><br><span class="line"><span class="comment"># 访存指令</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">a0</span>, <span class="number">0</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">a1</span>, <span class="number">4</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">t5</span>, <span class="number">8</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">t6</span>, <span class="number">12</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">t7</span>, <span class="number">16</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">t8</span>, <span class="number">20</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">t9</span>, <span class="number">24</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">a0</span>, <span class="number">0</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">a1</span>, <span class="number">12</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">a0</span>, <span class="number">28</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">a1</span>, <span class="number">32</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="comment"># 跳转指令</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="built_in">s4</span>, $<span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="built_in">s5</span>, $<span class="number">0</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="built_in">s6</span>, $<span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">s4</span>, $<span class="built_in">s6</span>, loop1     </span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">s4</span>, $<span class="built_in">s5</span>, loop2     </span><br><span class="line"><span class="symbol">loop1:</span><span class="keyword">sw </span>$<span class="built_in">s2</span>, <span class="number">36</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="keyword">lui </span>$<span class="built_in">s7</span>,<span class="number">65535</span></span><br><span class="line"><span class="symbol">loop2:</span><span class="keyword">sw </span>$<span class="built_in">s3</span>, <span class="number">40</span>($<span class="built_in">t0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/test2.jpg"
                      alt="1"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/test2.1.jpg"
                      alt="1"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/test2.2.jpg"
                      alt="1"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P3/test2.3.jpg"
                      alt="1"
                ><br>可见除$gp $sp 等特殊寄存器外，其他寄存器值相同<br>此外通过和同学对拍测试其他数据（包括边界数据65533、65535等），只有在使能端不关心这个数据（即这个数据并不进入这条指令对应的数据通路）时，数据会出现不同，其他情况下输出相同。</p>
<h2 id="2-2-自动测试工具"><a href="#2-2-自动测试工具" class="headerlink" title="2.2 自动测试工具"></a>2.2 自动测试工具</h2><p>该python程序可以实现将MIPS程序text.asm 转化成rom.txt并自动加载进存有cpu电路文件P3_v2.circ的ROM元件中，并生成新的电路文件P3_v2_remake.circ<br>使用虚拟机里python3然后CTRL+D退出，然后cd到python文件所在文件夹，输入<code>python3 -u &lt;filename&gt;.py</code> 即可执行python文件。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">command = <span class="string">&quot;java -jar Mars4_5.jar text1.asm nc mc CompactTextAtZero a dump .text HexText rom.txt&quot;</span></span><br><span class="line">os.system(command)</span><br><span class="line">content = <span class="built_in">open</span>(<span class="string">&quot;rom.txt&quot;</span>).read()</span><br><span class="line"></span><br><span class="line">circ = <span class="built_in">open</span>(<span class="string">&quot;P3_v2.circ&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>).read()</span><br><span class="line">circ = re.sub(<span class="string">r&#x27;addr/data: 5 32([\s\S]*)&lt;/a&gt;&#x27;</span>, <span class="string">&quot;addr/data: 5 32\n&quot;</span> + content + <span class="string">&quot;&lt;/a&gt;&quot;</span>, circ)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;P3_v2_remake.circ&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(circ)</span><br></pre></td></tr></table></figure></div>
<h1 id="3-思考题解答"><a href="#3-思考题解答" class="headerlink" title="3 思考题解答"></a>3 思考题解答</h1><ol>
<li>现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。<br>答：<br>①首先这个设计思路是合理的，ROM是是只读存储器，不能修改数据，可以用于存储指令，因此满足IM对于只读功能的需要；RAM是随机存储器，可以实现读取和写入数据，因此可以满足DM的读写功能需求；GRF是寄存器堆，用寄存器实现也是合理的。<br>②但我们应当注意到指令存储器为ROM时，存在过度简化。在大多数实际处理器中，指令存储器必须是可写的，从而使操作系统可以载入一个新的程序到存储器中。(好像黑书某个注释部分写的有，记不清楚辣)</li>
</ol>
<h1 id="祝P3上机一切顺利！"><a href="#祝P3上机一切顺利！" class="headerlink" title="祝P3上机一切顺利！"></a><strong>祝P3上机一切顺利！</strong></h1><h1 id="P3-Review"><a href="#P3-Review" class="headerlink" title="P3_Review"></a>P3_Review</h1><ol>
<li>具体题目记得不是很清楚了，前两个题比较简单，要注意的是在模块增加输入输出端口的时候，模块外观也会改变，接线可能出错，注意一下模块接口。</li>
<li>需要注意的是，课上的MARS需要导入新的指令，setting -&gt; load instruction，将下载的class.h文件导入。手写测试机器码真的太蠢了。</li>
</ol>
<h1 id="再接再励！一口气干到P8！"><a href="#再接再励！一口气干到P8！" class="headerlink" title="再接再励！一口气干到P8！"></a>再接再励！一口气干到P8！</h1>]]></content>
      <categories>
        <category>BUAA_CO</category>
      </categories>
      <tags>
        <tag>BUAA_CO</tag>
      </tags>
  </entry>
  <entry>
    <title>P5</title>
    <url>/2023/01/02/P5/</url>
    <content><![CDATA[<h1 id="1-P5-流水线CPU设计方案"><a href="#1-P5-流水线CPU设计方案" class="headerlink" title="1 P5 流水线CPU设计方案"></a>1 P5 流水线CPU设计方案</h1><h2 id="1-1-设计概述"><a href="#1-1-设计概述" class="headerlink" title="1.1 设计概述"></a>1.1 设计概述</h2><p>本文所设计的为Verilog实现的流水线MIPS架构CPU，该CPU支持10条指令，为此，笔者设计了PC,IM,D_Reg,D_MCU,CMP,GRF,EXT,NPC,E_Reg,E_MCU,ALU,M_Reg,M_MCU,DM,W_Reg,W_MCU模块。整体搭建采用自下而上的方式完成，该CPU的译码方式是分布式译码。<br>顶层模块设计图如下<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P5/%E8%AE%BE%E8%AE%A1%E5%9B%BE.png"
                      alt="1"
                ><br>信号控制如下<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P5/%E4%BF%A1%E5%8F%B7.png"
                      alt="1"
                ></p>
<h2 id="1-2-实现指令说明"><a href="#1-2-实现指令说明" class="headerlink" title="1.2 实现指令说明"></a>1.2 实现指令说明</h2><ul>
<li>cal_R : add,sub</li>
<li>cal_I :ori,lui(这里lui视为将立即数extend后的加法指令)</li>
<li>load ：lw</li>
<li>store : sw</li>
<li>B类指令 : beq</li>
<li>J类指令 : jal</li>
<li>特殊 : jr</li>
</ul>
<h1 id="2-工程模块定义"><a href="#2-工程模块定义" class="headerlink" title="2 工程模块定义"></a>2 工程模块定义</h1><h2 id="2-1-功能模块定义"><a href="#2-1-功能模块定义" class="headerlink" title="2.1 功能模块定义"></a>2.1 功能模块定义</h2><h3 id="2-1-1-PC"><a href="#2-1-1-PC" class="headerlink" title="2.1.1 PC"></a>2.1.1 PC</h3><ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
</tr>
<tr>
<td>stall</td>
<td>I</td>
<td>1</td>
<td>暂停信号</td>
</tr>
<tr>
<td>F_npc</td>
<td>I</td>
<td>32</td>
<td>下一条指令地址</td>
</tr>
<tr>
<td>F_pc8</td>
<td>O</td>
<td>32</td>
<td>F级pc+8</td>
</tr>
<tr>
<td>F_pc4</td>
<td>O</td>
<td>32</td>
<td>F级pc+4</td>
</tr>
<tr>
<td>F_pc</td>
<td>O</td>
<td>32</td>
<td>F级pc</td>
</tr>
</tbody></table>
</li>
<li>功能定义<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>同步复位</td>
<td>时钟上升沿到来且reset信号有效，PC寄存器中的值置为0x00003000</td>
</tr>
<tr>
<td>2</td>
<td>停止</td>
<td>时钟上升沿到来且stall信号有效，PC保持当前的值不变</td>
</tr>
<tr>
<td>3</td>
<td>写PC寄存器</td>
<td>时钟上升沿到来且reset和stall信号均失效，将npc写入PC寄存器</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-1-2-IM"><a href="#2-1-2-IM" class="headerlink" title="2.1.2 IM"></a>2.1.2 IM</h3><p>该模块由4096个32位寄存器组成，大小4096*32bits，用于存储指令<br>需要注意的是，因为指令的开始地址是0x00003000，所以在IM中取指令时，对应的应该是<code>F_pc - 0x00003000</code>，且由于是以字（4byte，32bits）为单位存储的，所以取<code>addr = temp[13:2]</code></p>
<ul>
<li>端口定义<br>|信号名|方向|位宽|描述|<br>|F_pc|I|32|F级指令的地址|<br>|F_instr|O|32|F级指令|</li>
</ul>
<h3 id="2-1-3-GRF"><a href="#2-1-3-GRF" class="headerlink" title="2.1.3 GRF"></a>2.1.3 GRF</h3><p>该模块包含32个具有写使能的32位寄存器，对应MIPS架构的$0~$31。<br>该模块可以实现同步复位和内部转发。</p>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
</tr>
<tr>
<td>A1</td>
<td>I</td>
<td>5</td>
<td>需要读取的第一个寄存器编号</td>
</tr>
<tr>
<td>A2</td>
<td>I</td>
<td>5</td>
<td>需要读取的第二个寄存器编号</td>
</tr>
<tr>
<td>A3</td>
<td>I</td>
<td>5</td>
<td>需要写入的寄存器编号,<strong>来自W级</strong></td>
</tr>
<tr>
<td>WriteData</td>
<td>I</td>
<td>32</td>
<td>需要写入的数据,<strong>来自W级</strong></td>
</tr>
<tr>
<td>RegWrite</td>
<td>I</td>
<td>1</td>
<td>寄存器堆写使能信号,<strong>来自W级</strong></td>
</tr>
<tr>
<td>pc</td>
<td>I</td>
<td>32</td>
<td>当前D级执行的指令</td>
</tr>
<tr>
<td>RD1</td>
<td>O</td>
<td>32</td>
<td>从A1寄存器中读取的数据</td>
</tr>
<tr>
<td>RD2</td>
<td>O</td>
<td>32</td>
<td>从A2寄存器中读取的数据</td>
</tr>
</tbody></table>
</li>
<li>功能定义<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>同步复位</td>
<td>时钟上升沿道到来且reset信号有效，GRF中数据清零</td>
</tr>
<tr>
<td>2</td>
<td>读数据</td>
<td>读出A1，A2编号对应的寄存器中的数据并将它分别加载到RD1和RD2</td>
</tr>
<tr>
<td>3</td>
<td>写数据</td>
<td>时钟上升沿到来且RegWrite信号有效，将WriteData写入A3对应寄存器</td>
</tr>
<tr>
<td>4</td>
<td>内部转发</td>
<td>当（A1&#x3D;&#x3D;A3） &amp;&amp; RegWrite &amp;&amp; A1 ！&#x3D; 0，将WriteData直接加载至RD1</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-1-4-CMP（用于B类指令）"><a href="#2-1-4-CMP（用于B类指令）" class="headerlink" title="2.1.4 CMP（用于B类指令）"></a>2.1.4 CMP（用于B类指令）</h3><p>该模块通过比较两个输入，输出信号是否执行B类指令的跳转。</p>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td>r1</td>
<td>I</td>
<td>32</td>
<td>需要比较的第一个数据</td>
<td>cmp1_Fwd转发后所得</td>
</tr>
<tr>
<td>r2</td>
<td>I</td>
<td>32</td>
<td>需要比较的第二个数据</td>
<td>cmp2_Fwd转发后所得</td>
</tr>
<tr>
<td>D_Branch</td>
<td>I</td>
<td>1</td>
<td>当前指令是否是beq指令</td>
<td>D_MCU输出</td>
</tr>
<tr>
<td>cmp_out</td>
<td>O</td>
<td>1</td>
<td>是否执行beq跳转</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-1-5-EXT"><a href="#2-1-5-EXT" class="headerlink" title="2.1.5 EXT"></a>2.1.5 EXT</h3><p>该模块根据EXTCtrl将指令中的16位立即数扩展位32位</p>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>imm16</td>
<td>I</td>
<td>16</td>
<td>需要位扩展的16位立即数</td>
</tr>
<tr>
<td>EXTCtrl</td>
<td>I</td>
<td>3</td>
<td>000：符号扩展 <br> 001:0扩展 <br> 010:将立即数加载到高位 <br> 011:signExt（imm + 00）</td>
</tr>
<tr>
<td>E32</td>
<td>O</td>
<td>32</td>
<td>位扩展结果</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-1-6-NPC"><a href="#2-1-6-NPC" class="headerlink" title="2.1.6 NPC"></a>2.1.6 NPC</h3><p>该模块通过控制信号和F_pc计算下一条指令的地址</p>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>E32</td>
<td>I</td>
<td>32</td>
<td>位扩展后的32位立即数，B类指令使用</td>
</tr>
<tr>
<td>imm26</td>
<td>I</td>
<td>26</td>
<td>指令中的26位立即数，jal指令使用</td>
</tr>
<tr>
<td>pc</td>
<td>I</td>
<td>32</td>
<td><strong>D_pc</strong></td>
</tr>
<tr>
<td>ra</td>
<td>I</td>
<td>32</td>
<td>cmp1_Fwd转发后得到的D_V1,jr指令使用</td>
</tr>
<tr>
<td>JCCtrl</td>
<td>I</td>
<td>2</td>
<td>00：pc+4或者beq<br>01：jal<br>10:jr</td>
</tr>
<tr>
<td>D_npc</td>
<td>I</td>
<td>32</td>
<td>跳转指令生效下一条指令地址</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-1-7-ALU"><a href="#2-1-7-ALU" class="headerlink" title="2.1.7 ALU"></a>2.1.7 ALU</h3><p>该模块实现算术运算</p>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SrcA</td>
<td>I</td>
<td>32</td>
<td>参与运算的第一个数据</td>
</tr>
<tr>
<td>SrcB</td>
<td>I</td>
<td>32</td>
<td>参与运算的第二个数据</td>
</tr>
<tr>
<td>ALUCtrl</td>
<td>I</td>
<td>3</td>
<td>000：A&amp;B <br> 001: A或B <br> 010: A+B <br> 110: A-B</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-1-8-DM"><a href="#2-1-8-DM" class="headerlink" title="2.1.8 DM"></a>2.1.8 DM</h3><p>该模块由3072个32位寄存器组成，容量3072*32bit</p>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
</tr>
<tr>
<td>MemWrite</td>
<td>I</td>
<td>1</td>
<td>寄存器堆写使能信号</td>
</tr>
<tr>
<td>pc</td>
<td>I</td>
<td>32</td>
<td>当前M级执行指令的pc</td>
</tr>
<tr>
<td>Addr</td>
<td>I</td>
<td>32</td>
<td>需要写入或者读取的地址</td>
</tr>
<tr>
<td>WriteData</td>
<td>I</td>
<td>32</td>
<td>需要写入的数据</td>
</tr>
<tr>
<td>RD</td>
<td>O</td>
<td>32</td>
<td>从相应地址读取的数据</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="2-2-流水寄存器模块定义"><a href="#2-2-流水寄存器模块定义" class="headerlink" title="2.2 流水寄存器模块定义"></a>2.2 流水寄存器模块定义</h2><h3 id="2-2-1-D级流水寄存器（IF-x2F-ID）"><a href="#2-2-1-D级流水寄存器（IF-x2F-ID）" class="headerlink" title="2.2.1 D级流水寄存器（IF&#x2F;ID）"></a>2.2.1 D级流水寄存器（IF&#x2F;ID）</h3><ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td>F_instr</td>
<td>I</td>
<td>32</td>
<td>F级instr输入</td>
<td>IM F_instr</td>
</tr>
<tr>
<td>F_pc</td>
<td>I</td>
<td>32</td>
<td>F级pc输入</td>
<td>PC F_pc</td>
</tr>
<tr>
<td>F_pc8</td>
<td>I</td>
<td>32</td>
<td>F级pc8输入</td>
<td>PC F_pc8</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位</td>
<td></td>
</tr>
<tr>
<td>stall</td>
<td>I</td>
<td>1</td>
<td>暂停信号，时钟上升沿到来且stall有效，D级流水寄存器数据保持不变</td>
<td>HCU stall</td>
</tr>
<tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
<td></td>
</tr>
<tr>
<td>D_instr</td>
<td>O</td>
<td>32</td>
<td>D级instr输出</td>
<td></td>
</tr>
<tr>
<td>D_pc8</td>
<td>O</td>
<td>32</td>
<td>D级pc8输出</td>
<td></td>
</tr>
<tr>
<td>D_pc</td>
<td>O</td>
<td>32</td>
<td>D级pc输出</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-2-2-E级流水寄存器（ID-x2F-EX）"><a href="#2-2-2-E级流水寄存器（ID-x2F-EX）" class="headerlink" title="2.2.2 E级流水寄存器（ID&#x2F;EX）"></a>2.2.2 E级流水寄存器（ID&#x2F;EX）</h3><ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
<td></td>
</tr>
<tr>
<td>stall</td>
<td>I</td>
<td>1</td>
<td>暂停信号，时钟上升沿到来且stall信号有效，E级流水寄存器清空</td>
<td>HCU stall</td>
</tr>
<tr>
<td>D_instr</td>
<td>I</td>
<td>32</td>
<td>D级instr输入</td>
<td>D_Reg D_instr</td>
</tr>
<tr>
<td>D_A1</td>
<td>I</td>
<td>5</td>
<td>D级A1输入</td>
<td>D_Reg D_instr[25:21]</td>
</tr>
<tr>
<td>D_A2</td>
<td>I</td>
<td>5</td>
<td>D级A2输入</td>
<td>D_Reg D_instr[20:16]</td>
</tr>
<tr>
<td>D_A3</td>
<td>I</td>
<td>5</td>
<td>D级A3输入</td>
<td>经RegDst信号选择后的D_A3</td>
</tr>
<tr>
<td>D_V1</td>
<td>I</td>
<td>32</td>
<td>D级的V1输入</td>
<td>经cmp1_Fwd<strong>转发</strong>后的数据</td>
</tr>
<tr>
<td>D_V2</td>
<td>I</td>
<td>32</td>
<td>D级的V2输入</td>
<td>经cmp2_Fwd<strong>转发</strong>后的数据</td>
</tr>
<tr>
<td>D_pc</td>
<td>I</td>
<td>32</td>
<td>D级的pc输入</td>
<td>D_Reg D_pc</td>
</tr>
<tr>
<td>D_pc8</td>
<td>I</td>
<td>32</td>
<td>D级的pc8输入</td>
<td>D_Reg D_pc8</td>
</tr>
<tr>
<td>D_E32</td>
<td>I</td>
<td>32</td>
<td>D级的E32输入</td>
<td>EXT E32</td>
</tr>
<tr>
<td>E_instr</td>
<td>O</td>
<td>32</td>
<td>E级的instr输出</td>
<td></td>
</tr>
<tr>
<td>E_A1</td>
<td>O</td>
<td>5</td>
<td>E级的A1输出</td>
<td></td>
</tr>
<tr>
<td>E_A2</td>
<td>O</td>
<td>5</td>
<td>E级的A2输出</td>
<td></td>
</tr>
<tr>
<td>E_A3</td>
<td>O</td>
<td>5</td>
<td>E级的A3输出</td>
<td></td>
</tr>
<tr>
<td>E_V1</td>
<td>O</td>
<td>32</td>
<td>E级的V1输出</td>
<td></td>
</tr>
<tr>
<td>E_V2</td>
<td>O</td>
<td>32</td>
<td>E级的V2输出</td>
<td></td>
</tr>
<tr>
<td>E_E32</td>
<td>O</td>
<td>32</td>
<td>E级的E32输出</td>
<td></td>
</tr>
<tr>
<td>E_pc8</td>
<td>O</td>
<td>32</td>
<td>E级的pc8输出</td>
<td></td>
</tr>
<tr>
<td>E_pc</td>
<td>O</td>
<td>32</td>
<td>E级的pc输出</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-2-3-M级流水寄存器（EX-x2F-MEM）"><a href="#2-2-3-M级流水寄存器（EX-x2F-MEM）" class="headerlink" title="2.2.3 M级流水寄存器（EX&#x2F;MEM）"></a>2.2.3 M级流水寄存器（EX&#x2F;MEM）</h3><ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
<td></td>
</tr>
<tr>
<td>E_instr</td>
<td>I</td>
<td>32</td>
<td>E级instr输入</td>
<td>E_Reg E_instr</td>
</tr>
<tr>
<td>E_A2</td>
<td>I</td>
<td>5</td>
<td>E级A2输入</td>
<td>E_Reg E_A2</td>
</tr>
<tr>
<td>E_A3</td>
<td>I</td>
<td>5</td>
<td>E级A3输入</td>
<td>E_Reg E_A3</td>
</tr>
<tr>
<td>E_AR</td>
<td>I</td>
<td>32</td>
<td>E级ALU计算结果</td>
<td>ALU AR</td>
</tr>
<tr>
<td>E_V2</td>
<td>I</td>
<td>32</td>
<td>E级V2输入</td>
<td>经ALUb_Fwd<strong>转发</strong>后得到的E_ALUSrcB_temp</td>
</tr>
<tr>
<td>E_pc8</td>
<td>I</td>
<td>32</td>
<td>E级pc8输入</td>
<td>E_Reg E_pc8</td>
</tr>
<tr>
<td>E_pc</td>
<td>I</td>
<td>32</td>
<td>E级pc输入</td>
<td>E_Reg E_pc</td>
</tr>
<tr>
<td>M_instr</td>
<td>O</td>
<td>32</td>
<td>M级instr输出</td>
<td></td>
</tr>
<tr>
<td>M_A2</td>
<td>O</td>
<td>5</td>
<td>M级的A2输出</td>
<td>HCU模块确定转发信号DM_Fwd时会使用</td>
</tr>
<tr>
<td>M_A3</td>
<td>O</td>
<td>5</td>
<td>M级的A3输出</td>
<td></td>
</tr>
<tr>
<td>M_AR</td>
<td>O</td>
<td>32</td>
<td>M级的AR输出</td>
<td></td>
</tr>
<tr>
<td>M_V2</td>
<td>O</td>
<td>32</td>
<td>M级的V2输出</td>
<td></td>
</tr>
<tr>
<td>M_pc8</td>
<td>O</td>
<td>32</td>
<td>M级的pc8输出</td>
<td></td>
</tr>
<tr>
<td>M_pc</td>
<td>O</td>
<td>32</td>
<td>M级的pc输出</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-2-4-W级流水寄存器（MEM-x2F-WB）"><a href="#2-2-4-W级流水寄存器（MEM-x2F-WB）" class="headerlink" title="2.2.4 W级流水寄存器（MEM&#x2F;WB）"></a>2.2.4 W级流水寄存器（MEM&#x2F;WB）</h3><ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
<td></td>
</tr>
<tr>
<td>M_instr</td>
<td>I</td>
<td>32</td>
<td>M级instr输入</td>
<td>M_Reg M_instr</td>
</tr>
<tr>
<td>M_A3</td>
<td>I</td>
<td>5</td>
<td>M级的A3输入</td>
<td>M_Reg M_A3</td>
</tr>
<tr>
<td>M_AR</td>
<td>I</td>
<td>32</td>
<td>M级的AR输入</td>
<td>M_Reg M_AR</td>
</tr>
<tr>
<td>M_RD</td>
<td>I</td>
<td>32</td>
<td>M级的RD输入</td>
<td>DM RD</td>
</tr>
<tr>
<td>M_pc8</td>
<td>I</td>
<td>32</td>
<td>M级的pc8输入</td>
<td>M_Reg M_pc8</td>
</tr>
<tr>
<td>M_pc</td>
<td>I</td>
<td>32</td>
<td>M级的pc输入</td>
<td>M_Reg M_pc</td>
</tr>
<tr>
<td>W_instr</td>
<td>O</td>
<td>32</td>
<td>W级instr输出</td>
<td></td>
</tr>
<tr>
<td>W_A3</td>
<td>O</td>
<td>5</td>
<td>W级A3输出</td>
<td></td>
</tr>
<tr>
<td>W_AR</td>
<td>O</td>
<td>32</td>
<td>W级AR输出</td>
<td></td>
</tr>
<tr>
<td>W_RD</td>
<td>O</td>
<td>32</td>
<td>W级RD输出</td>
<td></td>
</tr>
<tr>
<td>W_pc8</td>
<td>O</td>
<td>32</td>
<td>W级pc8输出</td>
<td></td>
</tr>
<tr>
<td>W_pc</td>
<td>O</td>
<td>32</td>
<td>W级pc输出</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="2-3-控制模块定义"><a href="#2-3-控制模块定义" class="headerlink" title="2.3 控制模块定义"></a>2.3 控制模块定义</h2><h3 id="2-3-1-MCU（主控制模块）"><a href="#2-3-1-MCU（主控制模块）" class="headerlink" title="2.3.1 MCU（主控制模块）"></a>2.3.1 MCU（主控制模块）</h3><p>在主控制模块通过解码opcode和func，分为and逻辑和or逻辑，输出控制信号。本CPU采用分布式译码，即在每一个流水级将MCU实例化一次，选择不同的输出信号。</p>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>instr</td>
<td>I</td>
<td>32</td>
<td>当前指令，流水级寄存器输出</td>
</tr>
<tr>
<td>RegDst</td>
<td>O</td>
<td>2</td>
<td>选择D_A3</td>
</tr>
<tr>
<td>Branch</td>
<td>O</td>
<td>1</td>
<td>当前是否时beq指令</td>
</tr>
<tr>
<td>EXTCtrl</td>
<td>O</td>
<td>3</td>
<td>立即数扩展控制信号</td>
</tr>
<tr>
<td>JCtrl</td>
<td>O</td>
<td>2</td>
<td>NPC模块跳转控制信号</td>
</tr>
<tr>
<td>ALUCtrl</td>
<td>O</td>
<td>3</td>
<td>ALU模块算术运算控制信号</td>
</tr>
<tr>
<td>ALUSrcBSel</td>
<td>O</td>
<td>1</td>
<td>ALU_Srcb选择信号</td>
</tr>
<tr>
<td>MemWrite</td>
<td>O</td>
<td>1</td>
<td>DM写使能信号</td>
</tr>
<tr>
<td>RegWrite</td>
<td>O</td>
<td>1</td>
<td>GRF写使能信号</td>
</tr>
<tr>
<td>jal</td>
<td>O</td>
<td>1</td>
<td>当前是否是jal信号，从而选择需要转发的data</td>
</tr>
<tr>
<td>MemtoReg</td>
<td>O</td>
<td>1</td>
<td>选择需要写入GRF的数据</td>
</tr>
<tr>
<td>Tuse_rs</td>
<td>O</td>
<td>2</td>
<td>只在D级输出，当前D级指令还有多久需要使用使用rs寄存器的值</td>
</tr>
<tr>
<td>Tuse_rt</td>
<td>O</td>
<td>2</td>
<td>只在D级输出，当前D级指令还有多久需要使用使用rt寄存器的值</td>
</tr>
<tr>
<td>D_Tnew</td>
<td>O</td>
<td>2</td>
<td>只在D级输出，当前D级指令还有多久产生需要写入GRF的数据（指该数据已经写入流水寄存器）（？）</td>
</tr>
<tr>
<td>E_Tnew</td>
<td>O</td>
<td>2</td>
<td>只在E级输出，当前E级指令还有多久产生需要写入GRF的数据</td>
</tr>
<tr>
<td>M_Tnew</td>
<td>O</td>
<td>2</td>
<td>只在M级输出，当前M级指令还有多久产生需要写入GRF的数据</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-3-2-HCU（冒险控制模块）"><a href="#2-3-2-HCU（冒险控制模块）" class="headerlink" title="2.3.2 HCU（冒险控制模块）"></a>2.3.2 HCU（冒险控制模块）</h3><p>在冒险控制模块通过“A-T”法分析<strong>转发</strong>还是<strong>暂停</strong></p>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Tuse_rs</td>
<td>I</td>
<td>2</td>
<td>当前D级指令还有多久需要使用rs寄存器的值</td>
</tr>
<tr>
<td>Tuse_rt</td>
<td>I</td>
<td>2</td>
<td>当前D级指令还有多久需要使用rt寄存器的值</td>
</tr>
<tr>
<td>E_Tnew</td>
<td>I</td>
<td>2</td>
<td>当前在E级的指令还有多久产生写入GRF的数据</td>
</tr>
<tr>
<td>M_Tnew</td>
<td>I</td>
<td>2</td>
<td>当前在M级的指令还有多久产生写入GRF的数据</td>
</tr>
<tr>
<td>E_RegWrite</td>
<td>I</td>
<td>1</td>
<td>当前E级指令的RegWrite信号</td>
</tr>
<tr>
<td>M_RegWrite</td>
<td>I</td>
<td>1</td>
<td>当前M级指令的RegWrite信号</td>
</tr>
<tr>
<td>W_RegWrite</td>
<td>I</td>
<td>1</td>
<td>当前W级指令的RegWrite信号</td>
</tr>
<tr>
<td>D_A1</td>
<td>I</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>D_A2</td>
<td>I</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>E_A1</td>
<td>I</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>E_A2</td>
<td>I</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>E_A3</td>
<td>I</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>M_A2</td>
<td>I</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>M_A3</td>
<td>I</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>W_A3</td>
<td>I</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>stall</td>
<td>O</td>
<td>1</td>
<td>暂停信号 <br>冻结PC的值  <br>冻结D级流水寄存器的值 <br>将E级流水寄存器清空</td>
</tr>
<tr>
<td>cmp1_Fwd</td>
<td>O</td>
<td>选择D_V1</td>
<td>00：RD1 <br> 10:M_Data</td>
</tr>
<tr>
<td>cmp2_Fwd</td>
<td>O</td>
<td>选择D_V2</td>
<td>00：RD2 <br> 10:M_Data</td>
</tr>
<tr>
<td>ALUa_Fwd</td>
<td>O</td>
<td>选择ALU_SrcA</td>
<td>00：E_V1 <br> 01:W_out <br> 10:M_Data</td>
</tr>
<tr>
<td>ALUb_Fwd</td>
<td>O</td>
<td>选择ALU_SrcB</td>
<td>00：E_V2 <br> 01:W_out <br> 10:M_Data</td>
</tr>
<tr>
<td>DM_Fwd</td>
<td>O</td>
<td>选择写入DM的数据</td>
<td>0：M_V2 <br> 01: W_out</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="2-4-选择模块"><a href="#2-4-选择模块" class="headerlink" title="2.4 选择模块"></a>2.4 选择模块</h2><h3 id="2-4-1-功能MUX"><a href="#2-4-1-功能MUX" class="headerlink" title="2.4.1 功能MUX"></a>2.4.1 功能MUX</h3><table>
<thead>
<tr>
<th>MUX名</th>
<th>描述</th>
<th>输出信号</th>
<th>控制信号</th>
</tr>
</thead>
<tbody><tr>
<td>MUX_npc</td>
<td>对PC模块F_npc输入信号进行选择</td>
<td>0：F_pc4 <br> 1: D_npc</td>
<td>npcSel</td>
</tr>
<tr>
<td>MUX_A3</td>
<td>对D级中A3输入信号进行选择<br>00:D_instr[20:16]<br>01:D_instr[15:11]<br>5’b11111</td>
<td>D_A3</td>
<td>E_RegDst</td>
</tr>
<tr>
<td>MUX_ALUB</td>
<td>对E级ALU模块SrcB接口的信号进行选择<br>0:E_ALUSrcB_temp <br> 1:E_E32</td>
<td>E_SrcB</td>
<td>ALUSrcBSel</td>
</tr>
<tr>
<td>MUX_M_Data</td>
<td>对M级data进行选择<br>0:M_V2 <br>1:W_out</td>
<td>M_Data</td>
<td>M_jal</td>
</tr>
<tr>
<td>MUX_W_Out</td>
<td>对W级data进行选择<br>00:W_AR<br>01:W_RD<br>10；W_pc8</td>
<td>W_out</td>
<td>MemtoReg</td>
</tr>
</tbody></table>
<h3 id="2-4-2-转发MUX"><a href="#2-4-2-转发MUX" class="headerlink" title="2.4.2 转发MUX"></a>2.4.2 转发MUX</h3><table>
<thead>
<tr>
<th>MUX名</th>
<th>描述</th>
<th>输出信号</th>
<th>控制信号</th>
</tr>
</thead>
<tbody><tr>
<td>HMUX_cmp1</td>
<td>将数据转发到D_V1端口</td>
<td>D_V1</td>
<td>cmp1_Fwd</td>
</tr>
<tr>
<td>HMUX_cmp2</td>
<td>将数据转发到D_V2端口</td>
<td>D_V2</td>
<td>cmp2_Fwd</td>
</tr>
<tr>
<td>HMUX_ALUa</td>
<td>将数据转发到ALUSrcA端口</td>
<td>E_SrcA</td>
<td>ALUa_Fwd</td>
</tr>
<tr>
<td>HMUX_ALUb</td>
<td>将数据转发到ALUSrcBtemp端口</td>
<td>E_SrcB_temp</td>
<td>ALUb_Fwd</td>
</tr>
<tr>
<td>HMUX_DM</td>
<td>将数据转发到DM_WD端口</td>
<td>M_WD</td>
<td>DM_Fwd</td>
</tr>
</tbody></table>
<h1 id="3-重要实现方法"><a href="#3-重要实现方法" class="headerlink" title="3 重要实现方法"></a>3 重要实现方法</h1><h2 id="3-1-分支转移实现"><a href="#3-1-分支转移实现" class="headerlink" title="3.1 分支转移实现"></a>3.1 分支转移实现</h2><h3 id="3-1-1-B类指令"><a href="#3-1-1-B类指令" class="headerlink" title="3.1.1 B类指令"></a>3.1.1 B类指令</h3><p>为了减少因控制冲突导致的暂停（stall），我们将B类指令的判断进行前置，单独使用CMP模块进行判断。如果cmp_out&#x3D;&#x3D;1 &amp;&amp; Branch&#x3D;&#x3D;1，进行跳转。</p>
<h3 id="3-1-2-jal"><a href="#3-1-2-jal" class="headerlink" title="3.1.2 jal"></a>3.1.2 jal</h3><p>当jal进入D级后（此时F级的指令为编译优化调度的指令），D_instr中imm26域的数据进入NPC进行处理，如果当前JCCtrl信号为2’b01（说明当前指令为jal指令），NPC输出转移的地址npc，并进入PC的输入端，在下一时钟沿上升时进入F级，实现转移。  </p>
<p>jal指令在实现跳转的同时，还需要将下一条指令的地址存入31号寄存器中，因此我们需要在F级中计算出改地址，并随着jal指令进行流水，最终在W级写入GRF的31号寄存器。由于存在延迟槽，pc+4地址中的指令是编译优化机制调度过来的，<strong>因此我们要保存的地址应该为pc+8</strong>。</p>
<h3 id="3-1-3-jr"><a href="#3-1-3-jr" class="headerlink" title="3.1.3 jr"></a>3.1.3 jr</h3><p>当jr进入D级后（此时F级的指令为编译优化调度的指令），D_V1（经过转发后的D_V1值）进入NPC，如果当前JCtrl为2’b10（说明当前指令为jr指令），NPC输出转移的地址npc，并进入PC的输入端，在下一时钟沿上升时进入F级，实现转移。</p>
<h2 id="3-2-冒险Harzard"><a href="#3-2-冒险Harzard" class="headerlink" title="3.2 冒险Harzard"></a>3.2 冒险Harzard</h2><p>“A-T”法</p>
<h3 id="3-2-1-暂停Stall"><a href="#3-2-1-暂停Stall" class="headerlink" title="3.2.1 暂停Stall"></a>3.2.1 暂停Stall</h3><p>当一个指令到达D级后，我们将它的Tuse与后面每一级Tnew比较以及A值校验，当Tuse &lt; Tnew时，阻塞流水线。<br>阻塞在D级：  </p>
<ul>
<li>冻结PC的值</li>
<li>冻结D级流水寄存器的值</li>
<li>将E级流水寄存器清空</li>
</ul>
<h3 id="3-2-2-转发Forward"><a href="#3-2-2-转发Forward" class="headerlink" title="3.2.2 转发Forward"></a>3.2.2 转发Forward</h3><p>当一个指令到达D级后，我们需要将它的Tuse与后面每一级Tnew比较以及A值校验，当Tuse &gt;&#x3D; Tnew,进行转发。<br>其中GRF实现内部转发。</p>
<h1 id="4-可能的拓展"><a href="#4-可能的拓展" class="headerlink" title="4 可能的拓展"></a>4 可能的拓展</h1><h2 id="4-1-draft"><a href="#4-1-draft" class="headerlink" title="4.1 draft"></a>4.1 draft</h2><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正数 原码 = 反码 = 补码</span></span><br><span class="line"><span class="comment">//负数 原码最高位为1；反码是原码符号位不变，其他位取反；补码是反码+1</span></span><br><span class="line"><span class="comment">//互为相反数</span></span><br><span class="line">((A + B == <span class="number">32&#x27;d0</span>) &amp;&amp; (!((A == <span class="number">32&#x27;h8000_0000</span>) &amp;&amp; (B == <span class="number">32&#x27;h8000_0000</span>))))</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件跳转，在CMP模块中增加判断功能</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//无条件链接，在MCU中更改RegDst、RegWrite、jal（或新设置一个信号）、MemtoReg</span></span><br><span class="line"><span class="comment">//条件链接/条件写，在D级生成D_check信号然后流水它，每一级根据这个信号判断写入地址和写入值</span></span><br><span class="line">D_check = D_bgezalc &amp; D_b_jump;</span><br><span class="line"><span class="keyword">assign</span> RFDst = <span class="comment">//...</span></span><br><span class="line">               bgezalc ? (check ? <span class="number">5&#x27;d31</span> : <span class="number">5&#x27;d0</span>) :</span><br><span class="line">               <span class="number">5&#x27;d0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不跳转时清空延迟槽</span></span><br><span class="line"><span class="comment">//如果当前处于stall状态，不能清空延迟槽，因为stall说明前面指令的Tnew大于Tuse，即需要传入CMP模块的两个值的最新值还没计算出来，因此还无法转发到CMP中</span></span><br><span class="line"><span class="keyword">wire</span> D_Reg_clr = check_D &amp; ~D_CMP_out &amp; ~stall;</span><br><span class="line"><span class="keyword">wire</span> clr = reset || D_Reg_clr;</span><br><span class="line"><span class="comment">//或者插入空泡</span></span><br><span class="line">F_instr = (~D_CMP_out &amp;&amp; check_D) ? <span class="number">32&#x27;d0</span> : im[pc[<span class="number">13</span>:<span class="number">2</span>] - <span class="number">12&#x27;hc00</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//条件存储</span></span><br><span class="line"><span class="comment">//check信号表示当前流水级是新指令</span></span><br><span class="line"><span class="comment">//condition满足写入rt，否则写31号</span></span><br><span class="line"><span class="keyword">assign</span> stall_rs_E = (D_A1 != <span class="number">5&#x27;d0</span>) &amp; (check_E ? (D_A1 == E_A3 | D_A1 == <span class="number">5&#x27;d31</span>) : D_A1 == E_A3) &amp; RegWrite_E &amp; (Tuse_rs &lt; Tnew_E);</span><br><span class="line"><span class="keyword">wire</span> D_A3_new = check_D ? (condition ? rt : <span class="number">5&#x27;d31</span>) : D_A3 ; </span><br><span class="line"></span><br><span class="line"><span class="comment">//condition满足写入31号，否则不写(写入$0)</span></span><br><span class="line"><span class="keyword">assign</span> stall_rs_E = (D_A1 != <span class="number">5&#x27;d0</span>) &amp; (check_E ? (D_A1 == <span class="number">5&#x27;d31</span> | D_A1 == <span class="number">5&#x27;d0</span>) : D_A1 == E_A3) &amp; RegWrite_E &amp; (Tuse_rs &lt; Tnew_E);</span><br><span class="line"><span class="keyword">wire</span> D_A3_new = check_D ? (condition ? <span class="number">5&#x27;d31</span> : <span class="number">5&#x27;d0</span>) : D_A3</span><br><span class="line"></span><br><span class="line"><span class="comment">//condition满足时写入DM读取值的低五位（不知道要写谁就stall吧）</span></span><br><span class="line"><span class="keyword">assign</span> stall_rt_M = (D_A2 != <span class="number">5&#x27;d0</span>) &amp; (check_M ? <span class="number">1&#x27;b1</span> : D_A2 == M_A3) &amp; RegWrite_M &amp; (Tuse_rt &lt; Tnew_M);</span><br><span class="line"><span class="keyword">wire</span> M_A3_new = check_M ? DM_out[<span class="number">4</span>:<span class="number">0</span>] : M_A3;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接Tnew = 0 才转发的条件转发</span></span><br><span class="line"><span class="keyword">assign</span> Fwd_cmp1 = ((D_A1 != <span class="number">5&#x27;d0</span>) &amp; (D_A1 == E_A3) &amp; RegWrite_E &amp; (Tnew_E == <span class="number">2&#x27;b00</span>)) ? <span class="number">2&#x27;b10</span> :</span><br><span class="line">                  ((D_A1 != <span class="number">5&#x27;d0</span>) &amp; (D_A1 == M_A3) &amp; RegWrite_M &amp; (Tnew_M == <span class="number">2&#x27;b00</span>)) ? <span class="number">2&#x27;b01</span> :</span><br><span class="line">                  <span class="number">2&#x27;d0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要考虑的信号</span></span><br><span class="line">EXTCtrl  ALUCtrl  JCtrl  RegDst  MemtoReg  ALUSrcBSel  M_jal  D_Branch  RegWrite   MemWrite   npcSel</span><br><span class="line">Tuse_rs Tuse_rt D_Tnew E_Tnew M_Tnew</span><br></pre></td></tr></table></figure></div>

<h1 id="5-思考题解答"><a href="#5-思考题解答" class="headerlink" title="5 思考题解答"></a>5 思考题解答</h1><ol>
<li>我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。<br>答：因为提前分支预判所需的数据需要从后续流水级转发而来，所以可能存在提前分支预判时正确数据并没有产生的情况<div class="highlight-container" data-rel="Mips"><figure class="iseeu highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add </span>$<span class="number">1</span>,$<span class="number">1</span>,$<span class="number">2</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="number">1</span>,$<span class="number">2</span>,label</span><br></pre></td></tr></table></figure></div>
是否提前分支预判，即CMP在D级或者在E级比较<code>$1</code>和<code>$2</code>减法结果是否为0，所需时钟周期都是一样的，因为都需要完成add指令E级的计算，而后把计算结果存入M级流水寄存器。</li>
<li>因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？<br>答：因为编译优化后，jal的下一条指令是pc+4，如果写回pc+4，当出现<code>jr $ra</code>时，将跳转到延迟槽，这样会导致重复执行延迟槽中的指令，所以要写回pc+8.</li>
<li>我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？<br>答：因为流水寄存器中存储的数据是上一级已经计算出来的数据，在当前周期内稳定输出。而功能部件的输出可能有延迟(详细看理论课PPT)，如果从功能部件提供转发数据，可能在正确转发数据生成前就转发了错误数据。</li>
<li>我们为什么要使用 GPR 内部转发？该如何实现？<br>答：这样可以将W级将要写入的数据及时加载到GRF的输出端口，从而减少数据冒险。实现如下：<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> RD1 = (A1 == A3 &amp;&amp; RegWrite &amp;&amp; A1 != <span class="number">0</span>) ? WriteData : <span class="comment">//内部转发</span></span><br><span class="line">             (A1 != <span class="number">0</span>) ? rf[A1] :</span><br><span class="line">             <span class="number">32&#x27;h0000_0000</span>;</span><br></pre></td></tr></table></figure></div></li>
<li>我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？<br>答：需求者：D级，E级，M级<br>供给者：E级，M级，W级<br>数据通路:<br>E-&gt;D，M-&gt;D,W-&gt;D;<br>         M-&gt;E,W-&gt;E;<br>         W-&gt;M;</li>
</ol>
<table>
<thead>
<tr>
<th>MUX名</th>
<th>描述</th>
<th>输出信号</th>
<th>控制信号</th>
</tr>
</thead>
<tbody><tr>
<td>HMUX_cmp1</td>
<td>将数据转发到D_V1端口</td>
<td>D_V1</td>
<td>cmp1_Fwd <br> 00：RD1 <br> 10:M_Data</td>
</tr>
<tr>
<td>HMUX_cmp2</td>
<td>将数据转发到D_V2端口</td>
<td>D_V2</td>
<td>cmp2_Fwd <br> 00：RD2 <br> 10:M_Data</td>
</tr>
<tr>
<td>HMUX_ALUa</td>
<td>将数据转发到ALUSrcA端口</td>
<td>E_SrcA</td>
<td>ALUa_Fwd <br> 00：E_V1 <br> 01:W_out <br> 10:M_Data</td>
</tr>
<tr>
<td>HMUX_ALUb</td>
<td>将数据转发到ALUSrcBtemp端口</td>
<td>E_SrcB_temp</td>
<td>ALUb_Fwd <br> E_V2 <br> 01:W_out <br> 10:M_Data</td>
</tr>
<tr>
<td>HMUX_DM</td>
<td>将数据转发到DM_WD端口</td>
<td>M_WD</td>
<td>DM_Fwd <br> 0：M_V2 <br> 01: W_out</td>
</tr>
<tr>
<td>6. 在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>①cal_R:修改ALU模块，MCU模块</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>②cal_I:修改EXT模块，ALU模块，MCU模块</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>③shift：修改ALU模块，MCU模块，EXT模块</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>④shiftv:修改ALU模块，MCU模块</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>⑤load：修改MCU模块，修改DM模块或者在DM模块外加一个对于字节的处理模块</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>⑥store：修改MCU模块，修改DM模块或者在DM模块外加一个对于字节的处理模块</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>⑦B类：修改CMP模块，MCU模块，NPC模块，EXT模块</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>⑧J类：修改MCU模块，NPC模块</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7. 简要描述你的译码器架构，并思考该架构的优势以及不足。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>答：我的译码器采用分布式译码。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>不足：分布式译码关键路径更长，速度较慢。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>优势：译码信息模块化，不需要流水传递信号。</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="祝P5上机一切顺利！"><a href="#祝P5上机一切顺利！" class="headerlink" title="祝P5上机一切顺利！"></a>祝P5上机一切顺利！</h1><h1 id="11-x2F-15-P5第一次上机"><a href="#11-x2F-15-P5第一次上机" class="headerlink" title="11&#x2F;15 P5第一次上机"></a>11&#x2F;15 P5第一次上机</h1><p>失败了失败了失败了<br>失败是成功之母，下周一定能过！<br>总的来说还是和往年题一样，条件存储 + 链接条件跳转 +  计算，注意题目顺序吧</p>
<ol>
<li>条件存储但是题目记不清楚了qaq，最难的放第一个了</li>
<li>原题，题目如下<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P5/P5T2.png"
                      alt="1"
                ><br>跟同学交流还是在判断D级当前指令是bonall且符合条件，那么就把F_instr 变成nop<br>maybe课下有bug或者哪里连错了？<br>这次上机好慌乱，顶层模块有一个注释直接把下一句话干没了。还有不要急着提交，应该每个信号都连好，自己把数据通路走一遍看有没有问题。有一些信号没连上的错误然后一直提交评测也好搞心态。<br>啊啊啊啊啊，判断相反数也写错了，应该是<code>（r1 + r2 == 32&#39;d0）&amp;&amp; (!((r1 == 32&#39;h8000_0000)&amp;&amp;(r2 == 32&#39;h8000_0000)))</code>不能同时为<code>32&#39;h8000_0000</code>写成都不能为<code>32&#39;h8000_0000</code>,错的好离谱</li>
<li>addoi<br>一个算术指令GPR[base] + imm，然后取反得temp，输出temp原码（还是补码，忘记了qaq）<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P5/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81.jpg"
                      alt="1"
                ><br><strong>取反是取相反数不是按位取反啊啊啊啊啊</strong><br>黑底的设计稿图片课上看的很难受，而且信号也不明显<br>要自己写简单的testbench，测了再交。不要着急提交。<br>我今天晚上在干什么呀</li>
</ol>
<h1 id="11-x2F-22-P5第二次上机"><a href="#11-x2F-22-P5第二次上机" class="headerlink" title="11&#x2F;22 P5第二次上机"></a>11&#x2F;22 P5第二次上机</h1><p>实在惊险，20：58提交通过</p>
<ol>
<li>保持良好的心态，不要慌乱</li>
<li>一定要写测试程序，只要暂停转发这些课下做好，课上只用检测该条指令的功能</li>
<li>愚蠢的错误实在太多：<br>①第一次上机不好好读RTL，根本不是题目要表达的意思。对着设计图，读好RTL，想好各种控制信号再动笔，一点一点改。<br>②if的条件语句的括号后面打了“；”<br>③r2[31]打成r2[1]，写的时候不要着急，慢慢的<br>④忘记声明变量位宽，导致出现xxx<br>⑤信号没连上</li>
</ol>
]]></content>
      <categories>
        <category>BUAA_CO</category>
      </categories>
      <tags>
        <tag>BUAA_CO</tag>
      </tags>
  </entry>
  <entry>
    <title>P6</title>
    <url>/2023/01/02/P6/</url>
    <content><![CDATA[<h1 id="1-P5-流水线CPU设计方案"><a href="#1-P5-流水线CPU设计方案" class="headerlink" title="1 P5 流水线CPU设计方案"></a>1 P5 流水线CPU设计方案</h1><h2 id="1-1-设计概述"><a href="#1-1-设计概述" class="headerlink" title="1.1 设计概述"></a>1.1 设计概述</h2><p>本文所设计的为Verilog实现的流水线MIPS架构CPU，该CPU支持28条指令，为此，笔者设计了PC，D_Reg, CMP，GRF，EXT，NPC，E_Reg,MDU，ALU，M_Reg,Load,Store,W_Reg,HCU模块，其中IM和DM通过外设实现。整体搭建采用自下而上的方式完成，该CPU的译码方式是分布式译码。<br>顶层模块设计图如下<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P6/%E8%AE%BE%E8%AE%A1%E7%A8%BF(1).jpg"
                      alt="1"
                > </p>
<h2 id="1-2-实现指令说明"><a href="#1-2-实现指令说明" class="headerlink" title="1.2 实现指令说明"></a>1.2 实现指令说明</h2><ul>
<li>cal_R : add,sub,and,or,slt,sltu,lui</li>
<li>cal_I : addi,andi,ori</li>
<li>load : lb,lh,lw</li>
<li>store : sb,sh,sw</li>
<li>B类指令 ： beq，bne</li>
<li>J类指令 ： jal，jr</li>
<li>md类 ：mult，multu,div,divu</li>
<li>mf类 ： mfhi，mflo</li>
<li>mt类 ： mthi，mtlo<br>所有指令均不考虑运算溢出</li>
</ul>
<h1 id="2-工程模块定义"><a href="#2-工程模块定义" class="headerlink" title="2 工程模块定义"></a>2 工程模块定义</h1><h2 id="2-1-顶层模块"><a href="#2-1-顶层模块" class="headerlink" title="2.1 顶层模块"></a>2.1 顶层模块</h2><ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
</tr>
<tr>
<td>i_inst_rdata</td>
<td>I</td>
<td>32</td>
<td>F级读入指令F_instr</td>
</tr>
<tr>
<td>m_data_rdata</td>
<td>I</td>
<td>32</td>
<td>M级读入数据</td>
</tr>
<tr>
<td>i_inst_addr</td>
<td>O</td>
<td>32</td>
<td>F_pc</td>
</tr>
<tr>
<td>m_data_addr</td>
<td>O</td>
<td>32</td>
<td>M_AR DM取数据地址</td>
</tr>
<tr>
<td>m_data_wdata</td>
<td>O</td>
<td>32</td>
<td>M_WD 写入DM数据</td>
</tr>
<tr>
<td>m_data_byteen</td>
<td>O</td>
<td>4</td>
<td>DM写入数据的字节使能</td>
</tr>
<tr>
<td>m_inst_addr</td>
<td>O</td>
<td>32</td>
<td>M_pc</td>
</tr>
<tr>
<td>w_grf_we</td>
<td>O</td>
<td>1</td>
<td>W_RegWrite</td>
</tr>
<tr>
<td>w_grf_addr</td>
<td>O</td>
<td>5</td>
<td>W_A3</td>
</tr>
<tr>
<td>w_grf_wdata</td>
<td>O</td>
<td>32</td>
<td>W_Data 写入GRF的数据</td>
</tr>
<tr>
<td>w_inst_addr</td>
<td>O</td>
<td>32</td>
<td>W_pc</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="2-2-功能模块定义"><a href="#2-2-功能模块定义" class="headerlink" title="2.2 功能模块定义"></a>2.2 功能模块定义</h2><h3 id="2-2-1-PC"><a href="#2-2-1-PC" class="headerlink" title="2.2.1 PC"></a>2.2.1 PC</h3><ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
</tr>
<tr>
<td>stall</td>
<td>I</td>
<td>1</td>
<td>暂停信号</td>
</tr>
<tr>
<td>F_npc</td>
<td>I</td>
<td>32</td>
<td>下一条指令地址</td>
</tr>
<tr>
<td>F_pc8</td>
<td>O</td>
<td>32</td>
<td>F级pc+8</td>
</tr>
<tr>
<td>F_pc4</td>
<td>O</td>
<td>32</td>
<td>F级pc+4</td>
</tr>
<tr>
<td>F_pc</td>
<td>O</td>
<td>32</td>
<td>F级pc</td>
</tr>
</tbody></table>
</li>
<li>功能定义<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>同步复位</td>
<td>时钟上升沿到来且reset信号有效，PC寄存器中的值置为0x00003000</td>
</tr>
<tr>
<td>2</td>
<td>停止</td>
<td>时钟上升沿到来且stall信号有效，PC保持当前的值不变</td>
</tr>
<tr>
<td>3</td>
<td>写PC寄存器</td>
<td>时钟上升沿到来且reset和stall信号均失效，将npc写入PC寄存器</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-2-2-CMP"><a href="#2-2-2-CMP" class="headerlink" title="2.2.2 CMP"></a>2.2.2 CMP</h3><p>该模块通过比较两个输入，输出信号是否执行B类指令的跳转。</p>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td>r1</td>
<td>I</td>
<td>32</td>
<td>需要比较的第一个数据</td>
<td>cmp1_Fwd转发后所得</td>
</tr>
<tr>
<td>r2</td>
<td>I</td>
<td>32</td>
<td>需要比较的第二个数据</td>
<td>cmp2_Fwd转发后所得</td>
</tr>
<tr>
<td>D_Branch</td>
<td>I</td>
<td>2</td>
<td>00:非B类指令 <br> 01:beq <br> 10:bne</td>
<td>D_MCU输出</td>
</tr>
<tr>
<td>cmp_out</td>
<td>O</td>
<td>1</td>
<td>是否执行B类跳转</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-2-3-GRF"><a href="#2-2-3-GRF" class="headerlink" title="2.2.3 GRF"></a>2.2.3 GRF</h3><p>该模块包含32个具有写使能的32位寄存器，对应MIPS架构的$0~$31。<br>该模块可以实现同步复位和内部转发。</p>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
</tr>
<tr>
<td>A1</td>
<td>I</td>
<td>5</td>
<td>需要读取的第一个寄存器编号</td>
</tr>
<tr>
<td>A2</td>
<td>I</td>
<td>5</td>
<td>需要读取的第二个寄存器编号</td>
</tr>
<tr>
<td>A3</td>
<td>I</td>
<td>5</td>
<td>需要写入的寄存器编号,<strong>来自W级</strong></td>
</tr>
<tr>
<td>WriteData</td>
<td>I</td>
<td>32</td>
<td>需要写入的数据,<strong>来自W级</strong></td>
</tr>
<tr>
<td>RegWrite</td>
<td>I</td>
<td>1</td>
<td>寄存器堆写使能信号,<strong>来自W级</strong></td>
</tr>
<tr>
<td>pc</td>
<td>I</td>
<td>32</td>
<td>当前D级执行的指令</td>
</tr>
<tr>
<td>RD1</td>
<td>O</td>
<td>32</td>
<td>从A1寄存器中读取的数据</td>
</tr>
<tr>
<td>RD2</td>
<td>O</td>
<td>32</td>
<td>从A2寄存器中读取的数据</td>
</tr>
</tbody></table>
</li>
<li>功能定义<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>同步复位</td>
<td>时钟上升沿道到来且reset信号有效，GRF中数据清零</td>
</tr>
<tr>
<td>2</td>
<td>读数据</td>
<td>读出A1，A2编号对应的寄存器中的数据并将它分别加载到RD1和RD2</td>
</tr>
<tr>
<td>3</td>
<td>写数据</td>
<td>时钟上升沿到来且RegWrite信号有效，将WriteData写入A3对应寄存器</td>
</tr>
<tr>
<td>4</td>
<td>内部转发</td>
<td>当（A1&#x3D;&#x3D;A3） &amp;&amp; RegWrite &amp;&amp; A1 ！&#x3D; 0，将WriteData直接加载至RD1</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-2-4-EXT"><a href="#2-2-4-EXT" class="headerlink" title="2.2.4 EXT"></a>2.2.4 EXT</h3><p>该模块根据EXTCtrl将指令中的16位立即数扩展位32位</p>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>imm16</td>
<td>I</td>
<td>16</td>
<td>需要位扩展的16位立即数</td>
</tr>
<tr>
<td>EXTCtrl</td>
<td>I</td>
<td>3</td>
<td>000：符号扩展 <br> 001:0扩展 <br> 010:将立即数加载到高位 <br> 011:signExt（imm + 00）</td>
</tr>
<tr>
<td>E32</td>
<td>O</td>
<td>32</td>
<td>位扩展结果</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-2-5-NPC"><a href="#2-2-5-NPC" class="headerlink" title="2.2.5 NPC"></a>2.2.5 NPC</h3><p>该模块通过控制信号和F_pc计算下一条指令的地址</p>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>E32</td>
<td>I</td>
<td>32</td>
<td>位扩展后的32位立即数，B类指令使用</td>
</tr>
<tr>
<td>imm26</td>
<td>I</td>
<td>26</td>
<td>指令中的26位立即数，jal指令使用</td>
</tr>
<tr>
<td>pc</td>
<td>I</td>
<td>32</td>
<td><strong>D_pc</strong></td>
</tr>
<tr>
<td>ra</td>
<td>I</td>
<td>32</td>
<td>cmp1_Fwd转发后得到的D_V1,jr指令使用</td>
</tr>
<tr>
<td>JCCtrl</td>
<td>I</td>
<td>2</td>
<td>00：pc+4或者B类指令 <br> 01：jal <br> 10:jr</td>
</tr>
<tr>
<td>D_npc</td>
<td>I</td>
<td>32</td>
<td>跳转指令生效下一条指令地址</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-2-6-MDU"><a href="#2-2-6-MDU" class="headerlink" title="2.2.6 MDU"></a>2.2.6 MDU</h3><p>该模块实现乘除法相关运算</p>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
</tr>
<tr>
<td>E_start</td>
<td>I</td>
<td>1</td>
<td>start为1表示当前E级为<strong>乘除运算</strong>指令</td>
</tr>
<tr>
<td>SrcA</td>
<td>I</td>
<td>32</td>
<td>参与运算的第一个数据</td>
</tr>
<tr>
<td>SrcB</td>
<td>I</td>
<td>32</td>
<td>参与运算的第二个数据</td>
</tr>
<tr>
<td>MDCtrl</td>
<td>I</td>
<td>4</td>
<td>乘除槽运算控制 <br> 0000:mult <br> 0001:multu <br> 0010:div <br> 0011:divu <br> 0100:mfhi <br> 0101:mflo <br> 0110:mthi <br> 0111:mtlo</td>
</tr>
<tr>
<td>MDR</td>
<td>O</td>
<td>32</td>
<td>mf类指令输出结果</td>
</tr>
<tr>
<td>busy</td>
<td>O</td>
<td>1</td>
<td>当前乘除槽正在进行md类指令，表示模拟延迟</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-2-7-ALU"><a href="#2-2-7-ALU" class="headerlink" title="2.2.7 ALU"></a>2.2.7 ALU</h3><p>该模块实现算术运算</p>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SrcA</td>
<td>I</td>
<td>32</td>
<td>参与运算的第一个数据</td>
</tr>
<tr>
<td>SrcB</td>
<td>I</td>
<td>32</td>
<td>参与运算的第二个数据</td>
</tr>
<tr>
<td>ALUCtrl</td>
<td>I</td>
<td>3</td>
<td>000：A&amp;B <br> 001: A或B <br> 010: A+B <br> 110: A-B <br> 011:slt <br> 100:sltu</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-2-8-Load"><a href="#2-2-8-Load" class="headerlink" title="2.2.8 Load"></a>2.2.8 Load</h3><p>该模块实现load类指令</p>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>m_data_rdata</td>
<td>I</td>
<td>32</td>
<td>从外部输入的DM读取初始数据</td>
</tr>
<tr>
<td>byte_Addr</td>
<td>I</td>
<td>2</td>
<td>M_AR[1:0],字节地址</td>
</tr>
<tr>
<td>loadOp</td>
<td>I</td>
<td>2</td>
<td>00：lw <br> 01:lh <br> 10:lb</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-2-9-Store"><a href="#2-2-9-Store" class="headerlink" title="2.2.9 Store"></a>2.2.9 Store</h3><p>该模块实现store类指令</p>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>WD_temp</td>
<td>I</td>
<td>32</td>
<td>准备向DM写入的初始数据</td>
</tr>
<tr>
<td>byteen</td>
<td>I</td>
<td>4</td>
<td>向DM写入数据的字节使能</td>
</tr>
<tr>
<td>WD</td>
<td>O</td>
<td>32</td>
<td>向DM写入的处理好的数据</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="2-3-流水寄存器模块定义"><a href="#2-3-流水寄存器模块定义" class="headerlink" title="2.3 流水寄存器模块定义"></a>2.3 流水寄存器模块定义</h2><h3 id="2-3-1-D级流水寄存器（IF-x2F-ID）"><a href="#2-3-1-D级流水寄存器（IF-x2F-ID）" class="headerlink" title="2.3.1 D级流水寄存器（IF&#x2F;ID）"></a>2.3.1 D级流水寄存器（IF&#x2F;ID）</h3><ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td>F_instr</td>
<td>I</td>
<td>32</td>
<td>F级instr输入</td>
<td>IM F_instr</td>
</tr>
<tr>
<td>F_pc</td>
<td>I</td>
<td>32</td>
<td>F级pc输入</td>
<td>PC F_pc</td>
</tr>
<tr>
<td>F_pc8</td>
<td>I</td>
<td>32</td>
<td>F级pc8输入</td>
<td>PC F_pc8</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位</td>
<td></td>
</tr>
<tr>
<td>stall</td>
<td>I</td>
<td>1</td>
<td>暂停信号，时钟上升沿到来且stall有效，D级流水寄存器数据保持不变</td>
<td>HCU stall</td>
</tr>
<tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
<td></td>
</tr>
<tr>
<td>D_instr</td>
<td>O</td>
<td>32</td>
<td>D级instr输出</td>
<td></td>
</tr>
<tr>
<td>D_pc8</td>
<td>O</td>
<td>32</td>
<td>D级pc8输出</td>
<td></td>
</tr>
<tr>
<td>D_pc</td>
<td>O</td>
<td>32</td>
<td>D级pc输出</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-3-2-E级流水寄存器（ID-x2F-EX）"><a href="#2-3-2-E级流水寄存器（ID-x2F-EX）" class="headerlink" title="2.3.2 E级流水寄存器（ID&#x2F;EX）"></a>2.3.2 E级流水寄存器（ID&#x2F;EX）</h3><ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
<td></td>
</tr>
<tr>
<td>stall</td>
<td>I</td>
<td>1</td>
<td>暂停信号，时钟上升沿到来且stall信号有效，E级流水寄存器清空</td>
<td>HCU stall</td>
</tr>
<tr>
<td>D_instr</td>
<td>I</td>
<td>32</td>
<td>D级instr输入</td>
<td>D_Reg D_instr</td>
</tr>
<tr>
<td>D_A1</td>
<td>I</td>
<td>5</td>
<td>D级A1输入</td>
<td>D_Reg D_instr[25:21]</td>
</tr>
<tr>
<td>D_A2</td>
<td>I</td>
<td>5</td>
<td>D级A2输入</td>
<td>D_Reg D_instr[20:16]</td>
</tr>
<tr>
<td>D_A3</td>
<td>I</td>
<td>5</td>
<td>D级A3输入</td>
<td>经RegDst信号选择后的D_A3</td>
</tr>
<tr>
<td>D_V1</td>
<td>I</td>
<td>32</td>
<td>D级的V1输入</td>
<td>经cmp1_Fwd<strong>转发</strong>后的数据</td>
</tr>
<tr>
<td>D_V2</td>
<td>I</td>
<td>32</td>
<td>D级的V2输入</td>
<td>经cmp2_Fwd<strong>转发</strong>后的数据</td>
</tr>
<tr>
<td>D_pc</td>
<td>I</td>
<td>32</td>
<td>D级的pc输入</td>
<td>D_Reg D_pc</td>
</tr>
<tr>
<td>D_pc8</td>
<td>I</td>
<td>32</td>
<td>D级的pc8输入</td>
<td>D_Reg D_pc8</td>
</tr>
<tr>
<td>D_E32</td>
<td>I</td>
<td>32</td>
<td>D级的E32输入</td>
<td>EXT E32</td>
</tr>
<tr>
<td>E_instr</td>
<td>O</td>
<td>32</td>
<td>E级的instr输出</td>
<td></td>
</tr>
<tr>
<td>E_A1</td>
<td>O</td>
<td>5</td>
<td>E级的A1输出</td>
<td></td>
</tr>
<tr>
<td>E_A2</td>
<td>O</td>
<td>5</td>
<td>E级的A2输出</td>
<td></td>
</tr>
<tr>
<td>E_A3</td>
<td>O</td>
<td>5</td>
<td>E级的A3输出</td>
<td></td>
</tr>
<tr>
<td>E_V1</td>
<td>O</td>
<td>32</td>
<td>E级的V1输出</td>
<td></td>
</tr>
<tr>
<td>E_V2</td>
<td>O</td>
<td>32</td>
<td>E级的V2输出</td>
<td></td>
</tr>
<tr>
<td>E_E32</td>
<td>O</td>
<td>32</td>
<td>E级的E32输出</td>
<td></td>
</tr>
<tr>
<td>E_pc8</td>
<td>O</td>
<td>32</td>
<td>E级的pc8输出</td>
<td></td>
</tr>
<tr>
<td>E_pc</td>
<td>O</td>
<td>32</td>
<td>E级的pc输出</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-3-3-M级流水寄存器（EX-x2F-MEM）"><a href="#2-3-3-M级流水寄存器（EX-x2F-MEM）" class="headerlink" title="2.3.3 M级流水寄存器（EX&#x2F;MEM）"></a>2.3.3 M级流水寄存器（EX&#x2F;MEM）</h3><ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
<td></td>
</tr>
<tr>
<td>E_instr</td>
<td>I</td>
<td>32</td>
<td>E级instr输入</td>
<td>E_Reg E_instr</td>
</tr>
<tr>
<td>E_A2</td>
<td>I</td>
<td>5</td>
<td>E级A2输入</td>
<td>E_Reg E_A2</td>
</tr>
<tr>
<td>E_A3</td>
<td>I</td>
<td>5</td>
<td>E级A3输入</td>
<td>E_Reg E_A3</td>
</tr>
<tr>
<td>E_AR</td>
<td>I</td>
<td>32</td>
<td>E级ALU计算结果</td>
<td>ALU AR</td>
</tr>
<tr>
<td>E_Data</td>
<td>I</td>
<td>32</td>
<td>E级当前指令的有效数据（MDR&#x2F;AR）</td>
<td></td>
</tr>
<tr>
<td>E_V2</td>
<td>I</td>
<td>32</td>
<td>E级V2输入</td>
<td>经ALUb_Fwd<strong>转发</strong>后得到的E_ALUSrcB_temp</td>
</tr>
<tr>
<td>E_pc8</td>
<td>I</td>
<td>32</td>
<td>E级pc8输入</td>
<td>E_Reg E_pc8</td>
</tr>
<tr>
<td>E_pc</td>
<td>I</td>
<td>32</td>
<td>E级pc输入</td>
<td>E_Reg E_pc</td>
</tr>
<tr>
<td>M_instr</td>
<td>O</td>
<td>32</td>
<td>M级instr输出</td>
<td></td>
</tr>
<tr>
<td>M_A2</td>
<td>O</td>
<td>5</td>
<td>M级的A2输出</td>
<td>HCU模块确定转发信号DM_Fwd时会使用</td>
</tr>
<tr>
<td>M_A3</td>
<td>O</td>
<td>5</td>
<td>M级的A3输出</td>
<td></td>
</tr>
<tr>
<td>M_AR</td>
<td>O</td>
<td>32</td>
<td>M级的AR输出</td>
<td></td>
</tr>
<tr>
<td>M_Datae</td>
<td>O</td>
<td>32</td>
<td>E级的Data输出到M级</td>
<td></td>
</tr>
<tr>
<td>M_V2</td>
<td>O</td>
<td>32</td>
<td>M级的V2输出</td>
<td></td>
</tr>
<tr>
<td>M_pc8</td>
<td>O</td>
<td>32</td>
<td>M级的pc8输出</td>
<td></td>
</tr>
<tr>
<td>M_pc</td>
<td>O</td>
<td>32</td>
<td>M级的pc输出</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-3-4-W级流水寄存器（MEM-x2F-WB）"><a href="#2-3-4-W级流水寄存器（MEM-x2F-WB）" class="headerlink" title="2.3.4 W级流水寄存器（MEM&#x2F;WB）"></a>2.3.4 W级流水寄存器（MEM&#x2F;WB）</h3><ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
<td></td>
</tr>
<tr>
<td>M_instr</td>
<td>I</td>
<td>32</td>
<td>M级instr输入</td>
<td>M_Reg M_instr</td>
</tr>
<tr>
<td>M_A3</td>
<td>I</td>
<td>5</td>
<td>M级的A3输入</td>
<td>M_Reg M_A3</td>
</tr>
<tr>
<td>M_AR</td>
<td>I</td>
<td>32</td>
<td>M级的AR输入</td>
<td>M_Reg M_AR</td>
</tr>
<tr>
<td>M_RD</td>
<td>I</td>
<td>32</td>
<td>M级的RD输入</td>
<td>Load RD</td>
</tr>
<tr>
<td>M_pc8</td>
<td>I</td>
<td>32</td>
<td>M级的pc8输入</td>
<td>M_Reg M_pc8</td>
</tr>
<tr>
<td>M_Data</td>
<td>I</td>
<td>32</td>
<td>M级指令对应的有效数据 M_Datae&#x2F;M_pc8</td>
<td></td>
</tr>
<tr>
<td>M_pc</td>
<td>I</td>
<td>32</td>
<td>M级的pc输入</td>
<td>M_Reg M_pc</td>
</tr>
<tr>
<td>W_instr</td>
<td>O</td>
<td>32</td>
<td>W级instr输出</td>
<td></td>
</tr>
<tr>
<td>W_A3</td>
<td>O</td>
<td>5</td>
<td>W级A3输出</td>
<td></td>
</tr>
<tr>
<td>W_AR</td>
<td>O</td>
<td>32</td>
<td>W级AR输出</td>
<td></td>
</tr>
<tr>
<td>W_RD</td>
<td>O</td>
<td>32</td>
<td>W级RD输出</td>
<td></td>
</tr>
<tr>
<td>W_pc8</td>
<td>O</td>
<td>32</td>
<td>W级pc8输出</td>
<td></td>
</tr>
<tr>
<td>W_Datam</td>
<td>O</td>
<td>32</td>
<td>M级Data输出</td>
<td></td>
</tr>
<tr>
<td>W_pc</td>
<td>O</td>
<td>32</td>
<td>W级pc输出</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="2-4-控制模块定义"><a href="#2-4-控制模块定义" class="headerlink" title="2.4 控制模块定义"></a>2.4 控制模块定义</h2><h3 id="2-4-1-MCU"><a href="#2-4-1-MCU" class="headerlink" title="2.4.1 MCU"></a>2.4.1 MCU</h3><p>在主控制模块通过解码opcode和func，分为and逻辑和or逻辑，输出控制信号。本CPU采用分布式译码，即在每一个流水级将MCU实例化一次，选择不同的输出信号。</p>
<ul>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>instr</td>
<td>I</td>
<td>32</td>
<td>当前指令，流水级寄存器输出</td>
</tr>
<tr>
<td>RegDst</td>
<td>O</td>
<td>2</td>
<td>选择D_A3</td>
</tr>
<tr>
<td>Branch</td>
<td>O</td>
<td>2</td>
<td>B类指令控制信号</td>
</tr>
<tr>
<td>EXTCtrl</td>
<td>O</td>
<td>3</td>
<td>立即数扩展控制信号</td>
</tr>
<tr>
<td>JCtrl</td>
<td>O</td>
<td>2</td>
<td>NPC模块跳转控制信号</td>
</tr>
<tr>
<td>ALUCtrl</td>
<td>O</td>
<td>3</td>
<td>ALU模块算术运算控制信号</td>
</tr>
<tr>
<td>MDCtrl</td>
<td>O</td>
<td>4</td>
<td>MDU模块乘除运算控制信号</td>
</tr>
<tr>
<td>start</td>
<td>O</td>
<td>1</td>
<td>表示当前是md类指令</td>
</tr>
<tr>
<td>mf</td>
<td>O</td>
<td>1</td>
<td>表示当前是mf类指令</td>
</tr>
<tr>
<td>ALUSrcBSel</td>
<td>O</td>
<td>1</td>
<td>ALU_Srcb选择信号</td>
</tr>
<tr>
<td>MemWrite</td>
<td>O</td>
<td>1</td>
<td>DM写使能信号</td>
</tr>
<tr>
<td>RegWrite</td>
<td>O</td>
<td>1</td>
<td>GRF写使能信号</td>
</tr>
<tr>
<td>loadOp</td>
<td>O</td>
<td>1</td>
<td>Load模块load指令控制信号</td>
</tr>
<tr>
<td>m_data_byteen</td>
<td>O</td>
<td>4</td>
<td>store类指令字节使能信号</td>
</tr>
<tr>
<td>jal</td>
<td>O</td>
<td>1</td>
<td>当前是否是jal信号，从而选择需要转发的data</td>
</tr>
<tr>
<td>MemtoReg</td>
<td>O</td>
<td>1</td>
<td>选择需要写入GRF的数据</td>
</tr>
<tr>
<td>Tuse_rs</td>
<td>O</td>
<td>2</td>
<td>只在D级输出，当前D级指令还有多久需要使用使用rs寄存器的值</td>
</tr>
<tr>
<td>Tuse_rt</td>
<td>O</td>
<td>2</td>
<td>只在D级输出，当前D级指令还有多久需要使用使用rt寄存器的值</td>
</tr>
<tr>
<td>D_Tnew</td>
<td>O</td>
<td>2</td>
<td>只在D级输出，当前D级指令还有多久产生需要写入GRF的数据</td>
</tr>
<tr>
<td>E_Tnew</td>
<td>O</td>
<td>2</td>
<td>只在E级输出，当前E级指令还有多久产生需要写入GRF的数据</td>
</tr>
<tr>
<td>M_Tnew</td>
<td>O</td>
<td>2</td>
<td>只在M级输出，当前M级指令还有多久产生需要写入GRF的数据</td>
</tr>
</tbody></table>
<h3 id="2-4-2-HCU"><a href="#2-4-2-HCU" class="headerlink" title="2.4.2 HCU"></a>2.4.2 HCU</h3>在冒险控制模块通过“A-T”法分析<strong>转发</strong>还是<strong>暂停</strong></li>
<li>端口定义<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Tuse_rs</td>
<td>I</td>
<td>2</td>
<td>当前D级指令还有多久需要使用rs寄存器的值</td>
</tr>
<tr>
<td>Tuse_rt</td>
<td>I</td>
<td>2</td>
<td>当前D级指令还有多久需要使用rt寄存器的值</td>
</tr>
<tr>
<td>E_Tnew</td>
<td>I</td>
<td>2</td>
<td>当前在E级的指令还有多久产生写入GRF的数据</td>
</tr>
<tr>
<td>M_Tnew</td>
<td>I</td>
<td>2</td>
<td>当前在M级的指令还有多久产生写入GRF的数据</td>
</tr>
<tr>
<td>E_RegWrite</td>
<td>I</td>
<td>1</td>
<td>当前E级指令的RegWrite信号</td>
</tr>
<tr>
<td>M_RegWrite</td>
<td>I</td>
<td>1</td>
<td>当前M级指令的RegWrite信号</td>
</tr>
<tr>
<td>W_RegWrite</td>
<td>I</td>
<td>1</td>
<td>当前W级指令的RegWrite信号</td>
</tr>
<tr>
<td>D_A1</td>
<td>I</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>D_A2</td>
<td>I</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>E_A1</td>
<td>I</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>E_A2</td>
<td>I</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>E_A3</td>
<td>I</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>M_A2</td>
<td>I</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>M_A3</td>
<td>I</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>W_A3</td>
<td>I</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>stall</td>
<td>O</td>
<td>1</td>
<td>暂停信号 <br>冻结PC的值  <br>冻结D级流水寄存器的值 <br>将E级流水寄存器清空</td>
</tr>
<tr>
<td>cmp1_Fwd</td>
<td>O</td>
<td>选择D_V1</td>
<td>00：RD1 <br> 10:M_Data</td>
</tr>
<tr>
<td>cmp2_Fwd</td>
<td>O</td>
<td>选择D_V2</td>
<td>00：RD2 <br> 10:M_Data</td>
</tr>
<tr>
<td>ALUa_Fwd</td>
<td>O</td>
<td>选择ALU_SrcA</td>
<td>00：E_V1 <br> 01:W_out <br> 10:M_Data</td>
</tr>
<tr>
<td>ALUb_Fwd</td>
<td>O</td>
<td>选择ALU_SrcB</td>
<td>00：E_V2 <br> 01:W_out <br> 10:M_Data</td>
</tr>
<tr>
<td>DM_Fwd</td>
<td>O</td>
<td>选择写入DM的数据</td>
<td>0：M_V2 <br> 01: W_out</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="2-5-选择模块"><a href="#2-5-选择模块" class="headerlink" title="2.5 选择模块"></a>2.5 选择模块</h2><h3 id="2-5-1-功能MUX"><a href="#2-5-1-功能MUX" class="headerlink" title="2.5.1 功能MUX"></a>2.5.1 功能MUX</h3><table>
<thead>
<tr>
<th>MUX名</th>
<th>描述</th>
<th>输出信号</th>
<th>控制信号</th>
</tr>
</thead>
<tbody><tr>
<td>MUX_npc</td>
<td>对PC模块F_npc输入信号进行选择</td>
<td>0：F_pc4 <br> 1: D_npc</td>
<td>npcSel</td>
</tr>
<tr>
<td>MUX_A3</td>
<td>对D级中A3输入信号进行选择<br>00:D_instr[20:16]<br>01:D_instr[15:11]<br>5’b11111</td>
<td>D_A3</td>
<td>E_RegDst</td>
</tr>
<tr>
<td>MUX_ALUB</td>
<td>对E级ALU模块SrcB接口的信号进行选择<br>0:E_ALUSrcB_temp <br> 1:E_E32</td>
<td>E_SrcB</td>
<td>ALUSrcBSel</td>
</tr>
<tr>
<td>MUX_E_Data</td>
<td>对E级的有效数据进行选择<br>0:E_AR<br>1:E_MDR</td>
<td>E_Data</td>
<td>E_mf</td>
</tr>
<tr>
<td>MUX_M_Data</td>
<td>对M级data进行选择<br>0:M_V2 <br>1:W_out</td>
<td>M_Data</td>
<td>M_jal</td>
</tr>
<tr>
<td>MUX_W_Out</td>
<td>对W级data进行选择<br>00:W_AR<br>01:W_RD<br>10；W_pc8</td>
<td>W_out</td>
<td>MemtoReg</td>
</tr>
</tbody></table>
<h3 id="2-5-2-转发MUX"><a href="#2-5-2-转发MUX" class="headerlink" title="2.5.2 转发MUX"></a>2.5.2 转发MUX</h3><table>
<thead>
<tr>
<th>MUX名</th>
<th>描述</th>
<th>输出信号</th>
<th>控制信号</th>
</tr>
</thead>
<tbody><tr>
<td>HMUX_cmp1</td>
<td>将数据转发到D_V1端口</td>
<td>D_V1</td>
<td>cmp1_Fwd</td>
</tr>
<tr>
<td>HMUX_cmp2</td>
<td>将数据转发到D_V2端口</td>
<td>D_V2</td>
<td>cmp2_Fwd</td>
</tr>
<tr>
<td>HMUX_ALUa</td>
<td>将数据转发到ALUSrcA端口</td>
<td>E_SrcA</td>
<td>ALUa_Fwd</td>
</tr>
<tr>
<td>HMUX_ALUb</td>
<td>将数据转发到ALUSrcBtemp端口</td>
<td>E_SrcB_temp</td>
<td>ALUb_Fwd</td>
</tr>
<tr>
<td>HMUX_DM</td>
<td>将数据转发到DM_WD端口</td>
<td>M_WD</td>
<td>DM_Fwd</td>
</tr>
</tbody></table>
<h1 id="3-重要实现方法"><a href="#3-重要实现方法" class="headerlink" title="3 重要实现方法"></a>3 重要实现方法</h1><h2 id="3-1-分支转移实现"><a href="#3-1-分支转移实现" class="headerlink" title="3.1 分支转移实现"></a>3.1 分支转移实现</h2><h3 id="3-1-1-B类指令"><a href="#3-1-1-B类指令" class="headerlink" title="3.1.1 B类指令"></a>3.1.1 B类指令</h3><p>为了减少因控制冲突导致的暂停（stall），我们将B类指令的判断进行前置，单独使用CMP模块进行判断。如果cmp_out&#x3D;&#x3D;1 &amp;&amp; Branch&#x3D;&#x3D;1，进行跳转。</p>
<h3 id="3-1-2-jal"><a href="#3-1-2-jal" class="headerlink" title="3.1.2 jal"></a>3.1.2 jal</h3><p>当jal进入D级后（此时F级的指令为编译优化调度的指令），D_instr中imm26域的数据进入NPC进行处理，如果当前JCCtrl信号为2’b01（说明当前指令为jal指令），NPC输出转移的地址npc，并进入PC的输入端，在下一时钟沿上升时进入F级，实现转移。  </p>
<p>jal指令在实现跳转的同时，还需要将下一条指令的地址存入31号寄存器中，因此我们需要在F级中计算出改地址，并随着jal指令进行流水，最终在W级写入GRF的31号寄存器。由于存在延迟槽，pc+4地址中的指令是编译优化机制调度过来的，因此我们要保存的地址应该为pc+8。</p>
<h3 id="3-1-3-jr"><a href="#3-1-3-jr" class="headerlink" title="3.1.3 jr"></a>3.1.3 jr</h3><p>当jr进入D级后（此时F级的指令为编译优化调度的指令），D_V1（经过转发后的D_V1值）进入NPC，如果当前JCtrl为2’b10（说明当前指令为jr指令），NPC输出转移的地址npc，并进入PC的输入端，在下一时钟沿上升时进入F级，实现转移。</p>
<h2 id="3-2-冒险Harzard"><a href="#3-2-冒险Harzard" class="headerlink" title="3.2 冒险Harzard"></a>3.2 冒险Harzard</h2><p>“A-T”法</p>
<h3 id="3-2-1-暂停Stall"><a href="#3-2-1-暂停Stall" class="headerlink" title="3.2.1 暂停Stall"></a>3.2.1 暂停Stall</h3><p>当一个指令到达D级后，我们将它的Tuse与后面每一级Tnew比较以及A值校验，当Tuse &lt; Tnew时，阻塞流水线。<br>阻塞在D级：  </p>
<ol>
<li>冻结PC的值</li>
<li>冻结D级流水寄存器的值</li>
<li>将E级流水寄存器清空</li>
</ol>
<h3 id="3-2-2-转发Forward"><a href="#3-2-2-转发Forward" class="headerlink" title="3.2.2 转发Forward"></a>3.2.2 转发Forward</h3><p>当一个指令到达D级后，我们需要将它的Tuse与后面每一级Tnew比较以及A值校验，当Tuse &gt;&#x3D; Tnew,进行转发。<br>其中GRF实现内部转发。</p>
<h2 id="3-3-乘除槽"><a href="#3-3-乘除槽" class="headerlink" title="3.3 乘除槽"></a>3.3 乘除槽</h2><p>设置MDU模块以支持乘除法以及mf类和md类指令。</p>
<h3 id="3-3-1-mf类指令"><a href="#3-3-1-mf类指令" class="headerlink" title="3.3.1 mf类指令"></a>3.3.1 mf类指令</h3><p>直接从HI，LO寄存器读取即可  </p>
<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> MDR = (MDCtrl == <span class="number">4&#x27;b0100</span>) ? HI :</span><br><span class="line">	         (MDCtrl == <span class="number">4&#x27;b0101</span>) ? LO :</span><br><span class="line">			 <span class="number">32&#x27;h0000_0000</span>;</span><br></pre></td></tr></table></figure></div>
<h3 id="3-3-2-mt类指令"><a href="#3-3-2-mt类指令" class="headerlink" title="3.3.2 mt类指令"></a>3.3.2 mt类指令</h3><p>将数据写入HI，LO寄存器即可</p>
<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> (MDCtrl)</span><br><span class="line">    <span class="number">4&#x27;b0110</span> : <span class="keyword">begin</span></span><br><span class="line">        HI &lt;= SrcA;</span><br><span class="line">		HI_temp &lt;= SrcA;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="number">4&#x27;b0111</span> : <span class="keyword">begin</span></span><br><span class="line">        LO &lt;= SrcA;</span><br><span class="line">		LO_temp &lt;= SrcA;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">default</span>: ;</span><br><span class="line">    <span class="keyword">endcase</span></span><br></pre></td></tr></table></figure></div>
<h3 id="3-3-3-md类指令"><a href="#3-3-3-md类指令" class="headerlink" title="3.3.3 md类指令"></a>3.3.3 md类指令</h3><p>对于md指令需要做到以下三点：</p>
<ol>
<li>当md类指令到达E级时，start信号置高，表示要开始处理md类指令</li>
<li>start信号置高后，乘法max赋值为5，除法max赋值为10，busy信号置高，cnt置1，运算结果存入temp寄存器</li>
<li>cnt每个周期自增，当达到max时，将temp寄存器的值写入HI，LO寄存器，同时cnt和busy_reg寄存器清零<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (E_start) <span class="keyword">begin</span> <span class="comment">//E级需要进行乘除法运算</span></span><br><span class="line">    <span class="keyword">case</span> (MDCtrl)</span><br><span class="line">        <span class="number">4&#x27;b0000</span> : <span class="keyword">begin</span></span><br><span class="line">            &#123;HI_temp,LO_temp&#125; &lt;= <span class="built_in">$signed</span> (SrcA) * <span class="built_in">$signed</span> (SrcB) ;</span><br><span class="line">            max &lt;= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="number">4&#x27;b0001</span> : <span class="keyword">begin</span></span><br><span class="line">            &#123;HI_temp,LO_temp&#125; &lt;= <span class="built_in">$unsigned</span> (SrcA) * <span class="built_in">$unsigned</span>(SrcB) ;</span><br><span class="line">            max &lt;= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="number">4&#x27;b0010</span> : <span class="keyword">begin</span></span><br><span class="line">            LO_temp &lt;= <span class="built_in">$signed</span> (SrcA) / <span class="built_in">$signed</span> (SrcB) ;</span><br><span class="line">            HI_temp &lt;= <span class="built_in">$signed</span> (SrcA) % <span class="built_in">$signed</span> (SrcB) ;</span><br><span class="line">            max &lt;= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="number">4&#x27;b0011</span> : <span class="keyword">begin</span></span><br><span class="line">            LO_temp &lt;= <span class="built_in">$unsigned</span> (SrcA) / <span class="built_in">$unsigned</span> (SrcB);</span><br><span class="line">            HI_temp &lt;= <span class="built_in">$unsigned</span> (SrcA) % <span class="built_in">$unsigned</span> (SrcB);</span><br><span class="line">            max &lt;= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">default</span>: ;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"># cnt busy</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk ) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (E_start) <span class="keyword">begin</span></span><br><span class="line">        busy_reg &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        cnt &lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((!E_start) &amp;&amp; (cnt == max) &amp;&amp; busy_reg) <span class="keyword">begin</span></span><br><span class="line">        busy_reg &lt;= <span class="number">0</span>;</span><br><span class="line">        cnt &lt;= <span class="number">0</span>;</span><br><span class="line">        HI &lt;= HI_temp;</span><br><span class="line">        LO &lt;= LO_temp;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((!E_start) &amp;&amp; ((cnt &gt;= <span class="number">1</span>) &amp;&amp; (cnt &lt; max)) &amp;&amp; busy_reg) <span class="keyword">begin</span></span><br><span class="line">        cnt &lt;= cnt + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">		cnt &lt;= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="3-3-4-冒险"><a href="#3-3-4-冒险" class="headerlink" title="3.3.4 冒险"></a>3.3.4 冒险</h3><p>当E级正在进行md类指令时，会把乘除指令均阻塞在D级</p>
<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> stall_MD = D_MD &amp;&amp; (E_busy || E_start);</span><br></pre></td></tr></table></figure></div>
<h1 id="4-思考题"><a href="#4-思考题" class="headerlink" title="4  思考题"></a>4  思考题</h1><ol>
<li><p>为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？<br>答：①因为乘除法计算有延迟，如果把乘除法部件整合进ALU就会影响到后面每一条涉及计算的指令，大大降低CPU的效率；而将乘除法部件单独设置，只会对后面涉及乘除法的指令产生影响<br>②乘除法指令涉及读写HI，LO寄存器，这与其他指令不同，根据“高内聚，低耦合”的原则，单独设立乘除法部件</p>
</li>
<li><p>真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。<br>答：①乘法：如图，将每个右边的加法器的输出作为左边加法器的输入，形成一个高32的加法器栈。将32个加法器组成组织成一个并行树，这样，只用等待log2(32) &#x3D; 5次32位长加法的时间，而不是等待32次加法的时间（《计算机组成与设计》P124 3.3.3 ）<br>②除法：与乘法同理，但是因为除法运算每次迭代前需要知道减法结果的符号，而乘法却可以即可生成32个部分积，因此除法需要10个周期延迟（结合书本，我的思考是这样的）。还有 一些技术可以每步生成不仅一个商位，如SRT算法。（？）</p>
</li>
<li><p>请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？<br>答：对于md指令需要做到以下三点：<br> ① 当md类指令到达E级时，start信号置高，表示要开始处理md类指令  </p>
<p>② start信号置高后，乘法max赋值为5，除法max赋值为10，busy信号置高，cnt置1，运算结果存入temp寄存器  </p>
<p>③ cnt每个周期自增，当达到max时，将temp寄存器的值写入HI，LO寄存器，同时cnt和busy_reg寄存器清零  </p>
<p>④阻塞条件</p>
<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> stall_MD = D_MD &amp;&amp; (E_busy || E_start);</span><br></pre></td></tr></table></figure></div></li>
<li><p>请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）<br>答：①清晰性：能够清晰知道哪个字节需要被写入<br>②统一性：对于sw，sh，sb等不同指令写入不同位，只需考虑字节使能信号哪些位置1即可，处理多种情况具有统一性</p>
</li>
<li><p>请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？<br>答：①实际从DM获得的数据和向DM写入数据都是一字，而不是一字节  </p>
<p>②对于半字访存或者字节访存时，按字节读或写的效率更高。如果此时还采用按字访问，则需要首先将整个字从内存中拿出来，然后再从字中寻找，效率会更低。</p>
</li>
<li><p>为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？<br>①将指令分类，分为cal_R,cal_I,load,store,md,mf,mt几类，用这些类来处理对应信号。<br>②用多位宽的信号表示相似信号，比如ALUCtrl，MDCtrl，EXTCCtrl，loadOp等</p>
</li>
</ol>
<h1 id="祝P6上机一切顺利！"><a href="#祝P6上机一切顺利！" class="headerlink" title="祝P6上机一切顺利！"></a>祝P6上机一切顺利！</h1>]]></content>
      <categories>
        <category>BUAA_CO</category>
      </categories>
      <tags>
        <tag>BUAA_CO</tag>
      </tags>
  </entry>
  <entry>
    <title>Pre</title>
    <url>/2023/01/02/Pre/</url>
    <content><![CDATA[<h1 id="Pre梳理"><a href="#Pre梳理" class="headerlink" title="Pre梳理"></a>Pre梳理</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h3><p>正数 ：原码 &#x3D; 反码 &#x3D; 补码</p>
<p>负数 ：原码 ：符号位为1，其后为绝对值的原码<br>反码 ：绝对值的原码各位取反<br>补码 ：反码 + 1 （或2^n - x）</p>
<p>计算机中的整数都用补码储存</p>
<h3 id="位宽大小"><a href="#位宽大小" class="headerlink" title="位宽大小"></a>位宽大小</h3><ol>
<li>1Byte &#x3D; 8bit</li>
<li>1字 &#x3D; 4Byte（32位机）</li>
<li>在写MIPS程序时，一个寄存器是32位，4字节，MIPS中的offset偏移操作都是以字节为单位的</li>
</ol>
<h2 id="Logisim"><a href="#Logisim" class="headerlink" title="Logisim"></a>Logisim</h2><ol>
<li>模块化设计的思想</li>
<li>注意外观以及题目所给要求</li>
<li>优雅的赋初值操作：<br>counter的输出端为initial，把counter设置为stay at max value，然后设置max value （maybe是1），再把initial标签与mux相接就可以啦  </li>
<li>理解电路的“同步”，这与我们平常写高级语言代码的设计是不同的</li>
<li>注意时钟周期要求，学会使用寄存器而不是直接进行输出</li>
</ol>
<h2 id="Verilog"><a href="#Verilog" class="headerlink" title="Verilog"></a>Verilog</h2><h3 id="阻塞赋值与非阻塞赋值"><a href="#阻塞赋值与非阻塞赋值" class="headerlink" title="阻塞赋值与非阻塞赋值"></a>阻塞赋值与非阻塞赋值</h3><ol>
<li>时序逻辑，非阻塞赋值（&lt;&#x3D;）；组合逻辑，阻塞赋值（&#x3D;）</li>
<li>组合逻辑和时序逻辑的always块分开</li>
<li>不要出现对同一个变量在多个always块中赋值，也不要出现一个变量既用阻塞赋值又用非阻塞赋值</li>
<li>判断输出时，可以把输出部分写在always块中，也可以写在always块外使用assign语句，assign相当于是组合逻辑中的一根线，输出会随着输入而发生变化<br>for example<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> rst) <span class="comment">//异步复位</span></span><br><span class="line">   <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">assign</span> ans = () ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="comment">// another</span></span><br><span class="line">   <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk,<span class="keyword">posedge</span> rst)</span><br><span class="line">   <span class="keyword">begin</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   ans = () ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line">   <span class="keyword">end</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><ol>
<li>Moore与Meely的选择<br>不用在最初设计电路时过多区分<br>Moore机可以满足输出一个cycle的要求<br>Meely机可以满足最早输出（越快越好的要求）<br>（详见L4 P25 波形示意图）<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/Pre/1.png"
                      alt="1"
                ></li>
<li>关键是次态逻辑与输出逻辑的设计<br>设计次态逻辑时，先想清楚你需要哪些状态，然后对这些状态进行编码，然后设计好状态转移图，根据图去编写代码<br>设计输出逻辑时，就要想清楚是Moore还是Meely，也就是说我的输入与当前输出是否有关</li>
</ol>
<h3 id="符号数处理"><a href="#符号数处理" class="headerlink" title="符号数处理"></a>符号数处理</h3><p>最保险的处理有符号数a:  </p>
<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$signed</span>(<span class="built_in">$signed</span>(a)&lt;&lt;b)</span><br></pre></td></tr></table></figure></div>
<h3 id="异步复位处理"><a href="#异步复位处理" class="headerlink" title="异步复位处理"></a>异步复位处理</h3><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk,<span class="keyword">posedge</span> rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">     <span class="keyword">if</span> (rst) state &lt;= `S0;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">case</span>(state)</span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">         <span class="keyword">default</span>: ;<span class="comment">//避免状态机跑飞了</span></span><br><span class="line">         <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></div>
<h3 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作"></a>初始化操作</h3><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span>  </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">     state &lt;= `S0;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></div>
<h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ol>
<li>注意不要忘记begin后的end，case后的default和endcase，以及最后的endmodule</li>
<li>模块端口定义的最后一行不要加’,’  <div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> counting(</span><br><span class="line"> <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] num,</span><br><span class="line"> <span class="keyword">input</span> clk,</span><br><span class="line"> <span class="keyword">input</span> ans <span class="comment">//不加&#x27;,&#x27;</span></span><br><span class="line">)；<span class="comment">//&#x27;；&#x27;不要忘记</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="例题标程"><a href="#例题标程" class="headerlink" title="例题标程"></a>例题标程</h3><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> S0 2&#x27;b00</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> S1 2&#x27;b01</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> S2 2&#x27;b10</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> S3 2&#x27;b11</span></span><br><span class="line"><span class="keyword">module</span> counting(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] num,</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> ans</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    status &lt;= `S0;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(status)</span><br><span class="line">        `S0: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (num == <span class="number">2&#x27;b01</span>)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    status &lt;= `S1;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">2&#x27;b10</span>)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    status &lt;= `S0;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">2&#x27;b11</span>)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    status &lt;= `S0;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    status &lt;= `S0; <span class="comment">// 对于一切非正常输出，回到状态0</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">default</span>: status &lt;= `S0;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">assign</span> ans = (status == `S3) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h2><h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><div class="highlight-container" data-rel="Mips"><figure class="iseeu highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="meta">.data</span></span><br><span class="line"><span class="comment">#.asciiz是字对齐的,可以放在前面，然后在后面申请空间(.space)</span></span><br><span class="line"><span class="meta">.text</span></span><br><span class="line"><span class="comment">#code</span></span><br><span class="line"><span class="meta">.word</span></span><br><span class="line"><span class="comment">#以字节存储</span></span><br></pre></td></tr></table></figure></div>
<h3 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h3><div class="highlight-container" data-rel="Mips"><figure class="iseeu highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字符串输出</span></span><br><span class="line">la $<span class="built_in">a0</span>,<span class="keyword">addr </span><span class="comment"># $a0：addr of the str；$a1: max size of the str；the end &#x27;\0&#x27;</span></span><br><span class="line">li $<span class="built_in">v0</span>,<span class="number">4</span></span><br><span class="line"><span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="comment">#整数输出</span></span><br><span class="line">li $<span class="built_in">v0</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span><span class="comment">#输出$a0寄存器中的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#读入一个整数</span></span><br><span class="line">li $<span class="built_in">v0</span>,<span class="number">5</span></span><br><span class="line"><span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">move </span>$<span class="built_in">s0</span>,$<span class="built_in">v0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#读入一个字符串</span></span><br><span class="line">li $<span class="built_in">v0</span>,<span class="number">8</span></span><br><span class="line"><span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span><span class="comment"># $a0 :the addr; $a1: the maxsize</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#读入一个字符</span></span><br><span class="line">li $<span class="built_in">v0</span>,<span class="number">12</span></span><br><span class="line"><span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span><span class="comment"># $v0 cotains it</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#结束程序</span></span><br><span class="line">li $<span class="built_in">v0</span>,<span class="number">10</span></span><br><span class="line"><span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span></span><br></pre></td></tr></table></figure></div>
<h1 id="上机总结"><a href="#上机总结" class="headerlink" title="上机总结"></a>上机总结</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>此次pre考的比较基础，只过了Verilog，感觉对于基础知识模型要加强学习</p>
<h2 id="Mealy机"><a href="#Mealy机" class="headerlink" title="Mealy机"></a>Mealy机</h2><p>此次Logisim和Verilog都考察的是Mealy型状态机  </p>
<h3 id="Mealy机的基本电路设计"><a href="#Mealy机的基本电路设计" class="headerlink" title="Mealy机的基本电路设计"></a>Mealy机的基本电路设计</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/Pre/2.jpg"
                      alt="1"
                ></p>
<h3 id="失误地方"><a href="#失误地方" class="headerlink" title="失误地方"></a>失误地方</h3><ol>
<li>题意不清，应该是对于每个输入都会判断与之前输入之和是否大于等于5</li>
<li>寄存器的使用,请注意en端口与clk端口<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/Pre/register.jpg"
                      alt="1"
                ></li>
</ol>
<h3 id="助教学长的标程"><a href="#助教学长的标程" class="headerlink" title="助教学长的标程"></a>助教学长的标程</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/Pre/3.jpg"
                      alt="1"
                ><br>有疑问：  </p>
<ol>
<li>没有实现大于零时清空寄存器<br>分析：使用mux实现的，如果all大于等于5，mux的选择端为1，mux输出为0，那么下一个时钟上升沿到来之时，register存入0，实现寄存器清零</li>
<li>为什么这是Mealy机呀，感觉输出状态是由输入状态唯一决定的<br>分析：每一个时钟上升沿到来，寄存器存入当前多路选择器的输出值，与in相加并判断是否大于等于5（Mealy）</li>
</ol>
<h2 id="Verilog-1"><a href="#Verilog-1" class="headerlink" title="Verilog"></a>Verilog</h2><p>考了异步复位以及状态转移</p>
<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> out = ((status == `S2)&amp;(in == <span class="number">1</span>)) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>; <span class="comment">//题目要求是Mealy机</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk,<span class="keyword">posedge</span> reset) <span class="comment">//异步复位</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (reset)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">case</span>(status)<span class="comment">//注意这里不要有冒号</span></span><br><span class="line">        `S0:</span><br><span class="line">        <span class="comment">//不要打成中文的标点，很容易就CTRL切换中英了</span></span><br><span class="line">        <span class="keyword">default</span>：；</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></div>

<h2 id="MIPS-1"><a href="#MIPS-1" class="headerlink" title="MIPS"></a>MIPS</h2><p>此次MIPS考察了求平方根，没有时间了就正向遍历，t了一个点，据大家讨论，反向遍历可以全过，正确做法是二分查找或者移位，主要考察对于循环的使用</p>
<h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><ol>
<li>掌握基础知识，比如verilog部分就是因为重点复习了状态机和异步复位等，在之前就把问题解决了（当然考到了这些问题），总之，多思考，多求教，多练习，帆帆加油！</li>
<li>对于机房环境，电脑容易卡掉线，不要慌多刷新几次；比较昏暗，注意键盘吧；不要被旁边同学影响了，专注自己，细心耐心静心，加油吧！</li>
</ol>
]]></content>
      <categories>
        <category>BUAA_CO</category>
      </categories>
      <tags>
        <tag>BUAA_CO</tag>
      </tags>
  </entry>
  <entry>
    <title>P7</title>
    <url>/2023/01/02/P7/</url>
    <content><![CDATA[<h1 id="P7-Study"><a href="#P7-Study" class="headerlink" title="P7_Study"></a>P7_Study</h1><h2 id="设计概述"><a href="#设计概述" class="headerlink" title="设计概述"></a>设计概述</h2><p>本文设计的是又Verilog实现的MIPS微系统，该微系统支持33条汇编指令，为实现该功能，笔者设计PC，CMP，GRF，EXT，NPC，ALU，MD，Load，Store，CP0，D_Reg,E_Reg,M_Reg,W_Reg,MCU,HCU,Bridge,TC模块。<br>顶层结构如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P7/P7%E9%A1%B6%E5%B1%82%E6%A8%A1%E5%9D%97.png"
                      alt="1"
                ><br>CPU内部如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/P7/CPU%E5%86%85%E9%83%A8.png"
                      alt="1"
                ></p>
<h2 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明"></a>指令说明</h2><ul>
<li>cal_R : add,sub,and,or,slt,sltu,lui</li>
<li>cal_I : addi,andi,ori</li>
<li>load : lb,lh,lw</li>
<li>store : sb,sh,sw</li>
<li>B类指令 ： beq，bne</li>
<li>J类指令 ： jal，jr</li>
<li>md类 ：mult，multu,div,divu</li>
<li>mf类 ： mfhi，mflo</li>
<li>mt类 ： mthi，mtlo  </li>
<li>CP0相关 ： mfc0,mtc0</li>
<li>异常中断返回 ： eret</li>
<li>其他 ： syscall</li>
</ul>
<h2 id="设计思考——两个思想"><a href="#设计思考——两个思想" class="headerlink" title="设计思考——两个思想"></a>设计思考——两个思想</h2><p>P7做的比较艰难，主要是刚开始对教程不太理解，后来在对于微系统的实现以及debug过程中与同学、助教进行了许多交流，才觉得对于P7微系统的稍微理解。回顾来看，我认为P7困扰我的其实是两个思想——软硬件协同的视角以及模块封装的思想，遂作此文，以分享笔者粗浅的思考。</p>
<h3 id="软硬件协同的视角"><a href="#软硬件协同的视角" class="headerlink" title="软硬件协同的视角"></a>软硬件协同的视角</h3><p>此处引用一位助教的原话“<strong>我们的硬件只需要忠诚地翻译指令</strong>”，所以我们只是实现硬件而不用去看软件要干什么，我们只要知道软件提出了什么需求，也就是我们的硬件要去实现怎样的接口（这里助教给我讲了一个形象的例子，后端-API-前端,后端不用去思考前端去干什么，实现好API接口即可）。<br>这也就解答了我在最初设计时两个很大的困惑：  </p>
<ul>
<li>如何处理中断？是在中断时把<code>m_data_addr</code>变成<code>0x7f20</code>吗？<br>答案是不用的， 是否访问<code>0x7f20</code>是软件程序去决定的事情，而我们的硬件只用支持软件去访问<code>0x7f20</code>即可。这也就实现了教程所言“<strong>对中断发生器的响应是通过系统桥来实现的，通过 store 类指令访问地址 0x7F20，就可以达到响应中断的目的</strong>”。</li>
<li>异常处理是怎样处理的？<br>这个问题真的困扰了我很久，但其实这是我们不用考虑的，异常处理是异常处理程序的事情，而我们的硬件只需要实现<strong>能够支持异常处理程序执行</strong>,也就是可以忠诚地翻译相应指令并且实现异常处理程序所需要的接口（也可以理解为保存好现场）即可。</li>
</ul>
<h3 id="模块封装"><a href="#模块封装" class="headerlink" title="模块封装"></a>模块封装</h3><p>我感觉刚做P7会有一种手忙脚乱的感觉，现在回看，<strong>模块封装</strong>的思想会帮助我们理清到底要干什么。其实我们要做的事情就是：</p>
<ul>
<li>在原来的流水线CPU中加入CP0模块，将其封装成新的CPU模块（这其中当然包括各种异常信号的识别与流水）</li>
<li>实现Bridge模块</li>
<li>实例化两个Timer</li>
<li>将CPU、Bridge 、Timer0、Timer1封装成我们的MIPS微系统<br>然后按照一个模块一个模块来实现就好</li>
</ul>
<h2 id="工程模块定义"><a href="#工程模块定义" class="headerlink" title="工程模块定义"></a>工程模块定义</h2><h3 id="CP0"><a href="#CP0" class="headerlink" title="CP0"></a>CP0</h3><table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
</tr>
<tr>
<td>en</td>
<td>I</td>
<td>1</td>
<td>写使能信号</td>
</tr>
<tr>
<td>BDIn</td>
<td>I</td>
<td>1</td>
<td>是否延迟槽指令</td>
</tr>
<tr>
<td>EXLClr</td>
<td>I</td>
<td>1</td>
<td>eret指令，复位EXL</td>
</tr>
<tr>
<td>ExcCode</td>
<td>I</td>
<td>5</td>
<td>异常类型编码</td>
</tr>
<tr>
<td>HWInt</td>
<td>I</td>
<td>6</td>
<td>中断信号</td>
</tr>
<tr>
<td>CP0Addr</td>
<td>I</td>
<td>5</td>
<td>需要访存的寄存器地址</td>
</tr>
<tr>
<td>CP0In</td>
<td>I</td>
<td>32</td>
<td>需要向CP0寄存器写入的数据，mtc0</td>
</tr>
<tr>
<td>vPC</td>
<td>I</td>
<td>32</td>
<td>受害PC，即M_pc</td>
</tr>
<tr>
<td>Req</td>
<td>O</td>
<td>1</td>
<td>进入异常处理程序请求</td>
</tr>
<tr>
<td>EPCout</td>
<td>O</td>
<td>32</td>
<td>EPC的值输出</td>
</tr>
<tr>
<td>CP0out</td>
<td>O</td>
<td>32</td>
<td>CP0寄存器读出的数据，mfc0</td>
</tr>
</tbody></table>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
</tr>
<tr>
<td>i_inst_rdata</td>
<td>I</td>
<td>32</td>
<td>读入指令，来自Bridge</td>
</tr>
<tr>
<td>m_data_rdata</td>
<td>I</td>
<td>32</td>
<td>从DM&#x2F;Timer&#x2F;IG读入数据，来自bridge</td>
</tr>
<tr>
<td>interrupt</td>
<td>I</td>
<td>1</td>
<td>IG输入中断信号（？）</td>
</tr>
<tr>
<td>Timer1</td>
<td>I</td>
<td>1</td>
<td>Timer1输入中断信号</td>
</tr>
<tr>
<td>Timer0</td>
<td>I</td>
<td>0</td>
<td>Timer0输入中断信号</td>
</tr>
<tr>
<td>i_inst_addr</td>
<td>O</td>
<td>32</td>
<td>F级pc，写向Bridge</td>
</tr>
<tr>
<td>m_data_addr</td>
<td>O</td>
<td>32</td>
<td>M级访存数据addr，写向Bridge</td>
</tr>
<tr>
<td>m_data_wdata</td>
<td>O</td>
<td>32</td>
<td>M级写入数据，写向Bridge</td>
</tr>
<tr>
<td>m_data_byteen</td>
<td>O</td>
<td>4</td>
<td>M级写入使能，写向Bridge</td>
</tr>
<tr>
<td>m_inst_addr</td>
<td>O</td>
<td>32</td>
<td>M级PC</td>
</tr>
<tr>
<td>w_grf_we</td>
<td>O</td>
<td>1</td>
<td>GRF写入使能</td>
</tr>
<tr>
<td>w_grf_addr</td>
<td>O</td>
<td>5</td>
<td>GRF写入的寄存器编号</td>
</tr>
<tr>
<td>w_grf_wdata</td>
<td>O</td>
<td>32</td>
<td>GRF写入数据</td>
</tr>
<tr>
<td>w_inst_addr</td>
<td>O</td>
<td>32</td>
<td>W级PC</td>
</tr>
<tr>
<td>macroscopic_pc</td>
<td>O</td>
<td>32</td>
<td>宏观PC，这里是M级PC</td>
</tr>
</tbody></table>
<h3 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h3><table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>A_in</td>
<td>I</td>
<td>32</td>
<td>读写外设单元地址,来自CPU</td>
</tr>
<tr>
<td>WD_in</td>
<td>I</td>
<td>32</td>
<td>写入外设单元的数据，来自CPU</td>
</tr>
<tr>
<td>byteen</td>
<td>I</td>
<td>4</td>
<td>写入外设单元使能，来自CPU</td>
</tr>
<tr>
<td>DM_RD</td>
<td>I</td>
<td>32</td>
<td>DM读取值输入，来自外设</td>
</tr>
<tr>
<td>T0_RD</td>
<td>I</td>
<td>32</td>
<td>T0读取值输入，来自外设</td>
</tr>
<tr>
<td>T1_RD</td>
<td>I</td>
<td>32</td>
<td>T1读取值输入，来自外设</td>
</tr>
<tr>
<td>RD_out</td>
<td>O</td>
<td>32</td>
<td>从外设读取的数据，写向CPU</td>
</tr>
<tr>
<td>A_out</td>
<td>O</td>
<td>32</td>
<td>读写外设单元地址，写向外设</td>
</tr>
<tr>
<td>WD_out</td>
<td>O</td>
<td>32</td>
<td>写入外设单元的数据，写向外设</td>
</tr>
<tr>
<td>DM_byteen</td>
<td>O</td>
<td>4</td>
<td>DM写入字节使能，写向外设</td>
</tr>
<tr>
<td>T0_WE</td>
<td>O</td>
<td>1</td>
<td>T0写入使能</td>
</tr>
<tr>
<td>T1_WE</td>
<td>O</td>
<td>1</td>
<td>T1写入使能</td>
</tr>
<tr>
<td>m_int_addr</td>
<td>O</td>
<td>32</td>
<td>中断发生器写入地址，写向外设</td>
</tr>
<tr>
<td>m_int_byteen</td>
<td>O</td>
<td>32</td>
<td>中断发生器写入字节使能，写向外设</td>
</tr>
</tbody></table>
<h3 id="TC"><a href="#TC" class="headerlink" title="TC"></a>TC</h3><table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
</tr>
<tr>
<td>Addr</td>
<td>I</td>
<td>30</td>
<td>Timer写入地址</td>
</tr>
<tr>
<td>WE</td>
<td>I</td>
<td>1</td>
<td>Timer写入使能</td>
</tr>
<tr>
<td>Din</td>
<td>I</td>
<td>32</td>
<td>Timer写入数据</td>
</tr>
<tr>
<td>Dout</td>
<td>O</td>
<td>32</td>
<td>Timer读出数据</td>
</tr>
<tr>
<td>IRQ</td>
<td>O</td>
<td>1</td>
<td>Timer中断请求</td>
</tr>
</tbody></table>
<h3 id="mips顶层模块"><a href="#mips顶层模块" class="headerlink" title="mips顶层模块"></a>mips顶层模块</h3><table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>同步复位信号</td>
</tr>
<tr>
<td>interrupt</td>
<td>I</td>
<td>1</td>
<td>外部中断信号</td>
</tr>
<tr>
<td>macroscopic_pc</td>
<td>O</td>
<td>32</td>
<td>宏观pc</td>
</tr>
<tr>
<td>i_inst_addr</td>
<td>O</td>
<td>32</td>
<td>IM读取地址，pc</td>
</tr>
<tr>
<td>i_inst_rdata</td>
<td>I</td>
<td>32</td>
<td>IM读取数据，来自外设</td>
</tr>
<tr>
<td>m_data_addr</td>
<td>O</td>
<td>32</td>
<td>DM读写地址</td>
</tr>
<tr>
<td>m_data_rdata</td>
<td>I</td>
<td>32</td>
<td>DM读取地址，来自外设</td>
</tr>
<tr>
<td>m_data_wdata</td>
<td>O</td>
<td>32</td>
<td>DM待写入数据</td>
</tr>
<tr>
<td>m_data_byteen</td>
<td>O</td>
<td>32</td>
<td>DM字节使能信号</td>
</tr>
<tr>
<td>m_int_addr</td>
<td>O</td>
<td>32</td>
<td>中断发生器待写入地址</td>
</tr>
<tr>
<td>m_int_byteen</td>
<td>O</td>
<td>4</td>
<td>中断发生器字节使能信号</td>
</tr>
<tr>
<td>m_inst_addr</td>
<td>O</td>
<td>32</td>
<td>M级PC</td>
</tr>
<tr>
<td>w_grf_we</td>
<td>O</td>
<td>1</td>
<td>GRF写使能信号</td>
</tr>
<tr>
<td>w_grf_wdata</td>
<td>O</td>
<td>32</td>
<td>GRF待写入数据</td>
</tr>
<tr>
<td>w_inst_addr</td>
<td>O</td>
<td>32</td>
<td>W级pc</td>
</tr>
</tbody></table>
<h2 id="重要方法实现"><a href="#重要方法实现" class="headerlink" title="重要方法实现"></a>重要方法实现</h2><h3 id="CP0响应"><a href="#CP0响应" class="headerlink" title="CP0响应"></a>CP0响应</h3><ul>
<li><strong>中断信息</strong>通过HWInt传入{3’b000,interrupt,Timer1,Timer0}</li>
<li><strong>异常信息</strong>通过ExcCode和BDIn传入<br>异常信号<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> IntReq = ((|(`IM &amp; HWInt)) &amp;&amp; `IE &amp;&amp; (!`EXL)); <span class="comment">//Interrupt</span></span><br><span class="line"><span class="keyword">assign</span> ExcReq = ((|ExcCodeIn) &amp;&amp; (!`EXL)); <span class="comment">//Exception</span></span><br><span class="line"><span class="keyword">assign</span> Req = IntReq || ExcReq;</span><br></pre></td></tr></table></figure></div>
中断优先级高于异常<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line">`ExcCode &lt;= (IntReq) ? <span class="number">5&#x27;b00000</span> : ExcCodeIn;</span><br></pre></td></tr></table></figure></div>
EPC的确定以及对于Req的操作<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> EPCout = (Req) ? ((BDIn) ? (vPC - <span class="number">4</span>) : vPC) : EPC ;</span><br><span class="line"> <span class="keyword">if</span> (Req) <span class="keyword">begin</span> <span class="comment">//int or exc</span></span><br><span class="line">            `EXL &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            `BD &lt;= BDIn;</span><br><span class="line">            `ExcCode &lt;= (IntReq) ? <span class="number">5&#x27;b00000</span> : ExcCodeIn;</span><br><span class="line">             EPC &lt;= EPCout;</span><br><span class="line">        <span class="keyword">end</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="系统桥"><a href="#系统桥" class="headerlink" title="系统桥"></a>系统桥</h3><p>系统桥实际上是实现与外设交换的功能，纯组合逻辑运算，代码如下：</p>
<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> A_out = A_in;</span><br><span class="line"><span class="keyword">assign</span> WD_out = WD_in;</span><br><span class="line"><span class="keyword">assign</span> DM_byteen = (A_in &gt;= <span class="number">32&#x27;h0000_0000</span> &amp;&amp; A_in &lt;= <span class="number">32&#x27;h0000_2fff</span>) ? byteen : <span class="number">4&#x27;b0000</span>;</span><br><span class="line"><span class="keyword">assign</span> T0_WE = (A_in &gt;= <span class="number">32&#x27;h0000_7f00</span> &amp;&amp; A_in &lt;= <span class="number">32&#x27;h0000_7f0b</span>) ? (&amp;byteen) : <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">assign</span> T1_WE = (A_in &gt;= <span class="number">32&#x27;h0000_7f10</span> &amp;&amp; A_in &lt;= <span class="number">32&#x27;h0000_7f1b</span>) ? (&amp;byteen) : <span class="number">1&#x27;b0</span>; </span><br><span class="line"><span class="keyword">assign</span> m_int_addr = (|m_int_byteen) ? A_in : <span class="number">32&#x27;h0000_0000</span>;</span><br><span class="line"><span class="keyword">assign</span> m_int_byteen = (A_in &gt;= <span class="number">32&#x27;h0000_7f20</span> &amp;&amp; A_in &lt;= <span class="number">32&#x27;h0000_7f23</span>) ? byteen : <span class="number">4&#x27;b0000</span>;</span><br><span class="line"><span class="keyword">assign</span> RD_out = (A_in &gt;= <span class="number">32&#x27;h0000_0000</span> &amp;&amp; A_in &lt;= <span class="number">32&#x27;h0000_2fff</span>) ? DM_RD :</span><br><span class="line">                (A_in &gt;= <span class="number">32&#x27;h0000_7f00</span> &amp;&amp; A_in &lt;= <span class="number">32&#x27;h0000_7f0b</span>) ? T0_RD :</span><br><span class="line">				(A_in &gt;= <span class="number">32&#x27;h0000_7f10</span> &amp;&amp; A_in &lt;= <span class="number">32&#x27;h0000_7f1b</span>) ? T1_RD :</span><br><span class="line">				<span class="number">32&#x27;h0000_0000</span>;</span><br></pre></td></tr></table></figure></div>
<h3 id="异常识别"><a href="#异常识别" class="headerlink" title="异常识别"></a>异常识别</h3><p><strong>前一级异常信号优先级更高，中断比异常优先级高</strong></p>
<ul>
<li>F级 <ul>
<li>AdEL 取指异常<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> F_ExcCode =  ((F_pc[<span class="number">1</span>:<span class="number">0</span>] != <span class="number">2&#x27;b00</span>) || (!((F_pc &gt;= <span class="number">32&#x27;h0000_3000</span>) &amp;&amp; (F_pc &lt;= <span class="number">32&#x27;h0000_6ffc</span>))) ) ? `AdEL : <span class="number">5&#x27;b00000</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li>D级 <ul>
<li>RI 未知指令 </li>
<li>Syscall指令<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> D_ExcCode_fixed = (|D_ExcCode) ? D_ExcCode :</span><br><span class="line">	                     (D_syscall) ? `Syscall :</span><br><span class="line">                         (D_RI) ? `RI :</span><br><span class="line">						 <span class="number">5&#x27;b00000</span> ;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li>E级 <ul>
<li>Ov 算术指令计算溢出</li>
<li>AdEL load类指令范围计算溢出</li>
<li>AdES store类指令范围计算溢出<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> E_ExcCode_fixed = (|E_ExcCode) ? E_ExcCode :</span><br><span class="line">	                     (E_OvCalInstr) ? (E_Overflow ? `Ov : E_ExcCode) :</span><br><span class="line">                         (E_OvLoadInstr) ? (E_Overflow ? `AdEL : E_ExcCode) :</span><br><span class="line">                         (E_OvSaveInstr) ? (E_Overflow ? `AdES : E_ExcCode) :</span><br><span class="line">                         <span class="number">5&#x27;b00000</span>; </span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li>M级 <ul>
<li>AdEL lw取数没有字对齐</li>
<li>AdES sw存数没有字对齐</li>
<li>AdEL lh取数没有半字对齐</li>
<li>AdES sh存数没有半字对齐</li>
<li>AdEL load类指令取数超出DM、T0、T1、IG范围</li>
<li>AdES store类指令存数超出DM、T0、T1、IG范围</li>
<li>AdEL lh、lb指令访问Timer寄存器</li>
<li>AdES sh、sb指令访存Timer寄存器</li>
<li>AdES sw向Timer的count寄存器存数<div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> M_ExcCode_fixed = (|M_ExcCode) ? M_ExcCode :</span><br><span class="line">	                     ((M_lw || M_lh || M_lb) &amp;&amp; (!M_DM_Addr) &amp;&amp; (!M_Timer_Addr) &amp;&amp; (!M_IG_Addr)) ? `AdEL :</span><br><span class="line">                         ((M_sw || M_sh || M_sb) &amp;&amp; (!M_DM_Addr) &amp;&amp; (!M_Timer_Addr) &amp;&amp; (!M_IG_Addr)) ? `AdES :<span class="comment">//越界</span></span><br><span class="line">                         ((M_lw) &amp;&amp; (M_AR[<span class="number">1</span>:<span class="number">0</span>] != <span class="number">2&#x27;b00</span>)) ? `AdEL :</span><br><span class="line">                         ((M_sw) &amp;&amp; (M_AR[<span class="number">1</span>:<span class="number">0</span>] != <span class="number">2&#x27;b00</span>)) ? `AdES : <span class="comment">//没有字对齐</span></span><br><span class="line">                         ((M_lh) &amp;&amp; (M_AR[<span class="number">0</span>] != <span class="number">1&#x27;b0</span>)) ? `AdEL :</span><br><span class="line">                         ((M_sh) &amp;&amp; (M_AR[<span class="number">0</span>] != <span class="number">1&#x27;b0</span>)) ? `AdES : <span class="comment">//没有半字对齐</span></span><br><span class="line">                         ((M_lh || M_lb) &amp;&amp; M_Timer_Addr) ? `AdEL : <span class="comment">//半字或字节访问Timer</span></span><br><span class="line">                         ((M_sh || M_sb) &amp;&amp; M_Timer_Addr) ? `AdES : <span class="comment">//半字或字节写入Timer</span></span><br><span class="line">						 ((M_sw) &amp;&amp; ((M_AR == <span class="number">32&#x27;h0000_7f08</span>) || (M_AR == <span class="number">32&#x27;h0000_7f18</span>))) ? `AdES : </span><br><span class="line">                         <span class="number">5&#x27;b00000</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<h2 id="思考题解答"><a href="#思考题解答" class="headerlink" title="思考题解答"></a>思考题解答</h2><ol>
<li>请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）<br>答：这样更方便CPU的统一设计。我认为是可以的，用户需要多输入一个信号，即异常处理程序的初始地址。问题就是，用户提供的初始地址可能与本来的其他存储地址起冲突。</li>
<li>为何与外设通信需要 Bridge？<br>答：因为我们的CPU可能会与许多外设相连，如果为每一个外设提供一套数据和地址，就会让CPU变得非常复杂。这里Bridge充当一个交互的角色，将多个外设与CPU连起来，这样我们的CPU只用提供一个接口即可。</li>
<li>倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？<br>答：此时宏观pc会突然变成0x3000这与我们想把整个CPU包装成单周期CPU的想法冲突。stall清空E级流水寄存器应该保留pc（保证宏观pc正确）和BD信号（保证该nop走到M级遇见中断写入CP0的pc信息是正确的）</li>
<li>为什么 jalr 指令为什么不能写成 jalr $31, $31？<br>答：因为<code>jalr $31,$31</code>，是要同时读写$31，而GRF具有内部转发，也就是在其他i1与i2同时读写一个寄存器时，会直接把写的数据加载到读端口，如此jalr就读出的是PC+4，并没有实现原先的跳转功能。</li>
</ol>
<h2 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h2><p>因为自己和身边的同学都或多或少找到了中测没测出来的bug，我觉得大家如果愿意的话可以在这篇帖子下面分享自己bug。（P7debug过程实在艰难）</p>
<ul>
<li>Req越沿采样错误，应该是Req置高的下一个周期F级pc才变为<code>0x4180</code>（笔者的Req是wire型，组合逻辑运算输出）<br>此处再次引用助教的讲解，信号在一个时钟周期中应该是<strong>左开右闭</strong>的。<strong>左开</strong>是为了在时钟上升沿保持稳定，<strong>右闭</strong>是为了保证下一时钟上升沿在稳定状态采样，所以要遵循这个理念，不能够越沿采样。</li>
<li>中断的优先级高于异常，即如果CP0中中断信号有效那么ExcCode就是<code>5&#39;d0</code>，否则才是输入的ExcCode</li>
<li>sw指令可以访存Timer的前两个寄存器，而不能访问count寄存器，这里可以根据Timer设计文档确定count的Addr</li>
<li>W级流水寄存器在Req信号置高时也是要清空的，所有流水寄存器都要在Req信号置高时清空</li>
<li>如果E级是mtlo&#x2F;mthi&#x2F;mult&#x2F;div这些指令，M级输出Req，那么不要执行E级计算</li>
<li>各种地址范围敲错</li>
<li>中断的时候DM写使能也要关掉！<code>req</code>和<code>|ExcCode</code>别写混了，想清楚再写</li>
</ul>
<h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><ul>
<li>function测试<br>过了P6就问题不大，其实功能部分是不用怎么修改的</li>
<li>exception测试<br>就是把教程提到的各种异常都枚举测试一遍，尤其注意乘除槽相关</li>
<li>interrupt测试<br>枚举各种情况下的中断，写一个支持中断的tb</li>
</ul>
<h1 id="祝上机顺利！"><a href="#祝上机顺利！" class="headerlink" title="祝上机顺利！"></a>祝上机顺利！</h1>]]></content>
      <categories>
        <category>BUAA_CO</category>
      </categories>
      <tags>
        <tag>BUAA_CO</tag>
      </tags>
  </entry>
  <entry>
    <title>my first blog</title>
    <url>/2022/12/27/my%20first%20blog/my-first-blog/</url>
    <content><![CDATA[<h1 id="P0-Study"><a href="#P0-Study" class="headerlink" title="P0_Study"></a>P0_Study</h1><h2 id="电路分析设计"><a href="#电路分析设计" class="headerlink" title="电路分析设计"></a>电路分析设计</h2><ol>
<li>Input与Output分析</li>
<li>功能分析<br>（可以先进行类似于表格的书面化说明，明白好设计思路与设计需求再去设计电路）</li>
<li>分层设计与分模块设计<br>模块类似于函数的封装，便于理清思路、清晰电路、debug<br>eg1.Moore机与Mealy机都可以划分为状态转移、状态存储、输出模块<br>eg2.32位加法器分为多个一位加法器<br>PS：注意子电路的<strong>appearance</strong>，要跟题目要求一致</li>
</ol>
<h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>首先回顾一下Moore和Mealy叭！<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset/Moore&Mealy.png"
                      alt="1"
                ></p>
<ol>
<li>状态转移电路一般只是<strong>组合逻辑</strong>的计算，也就是说随着input的变化（无论clk处于什么状态），其计算的状态也相应发生，所以一定要有<em>状态存储</em>模块，clk处于上升沿时输出prev_state存入now_state</li>
<li>对于组合逻辑部分，画好状态转移图，一个经济有效的方法就是<em>打表</em>，利用analyze circuit来实现  </li>
<li>一定弄清题目对于输出的要求，<em>正确使用register</em></li>
</ol>
<h2 id="线路颜色不对报错"><a href="#线路颜色不对报错" class="headerlink" title="线路颜色不对报错"></a>线路颜色不对报错</h2><p>小结：</p>
<ol>
<li>红色 E 的可能原因：短路&#x2F;多驱动，门电路没接输入，多驱动即相当于多个逻辑运算assign同一个output，这当然是不行的</li>
<li>状态转移模块是组合逻辑，不需要时钟，不需要 reset</li>
<li>真值表生成电路功能的使用  </li>
<li>不要在组合逻辑电路中出现环路，否则会出现震荡！</li>
</ol>
<h2 id="question"><a href="#question" class="headerlink" title="question"></a>question</h2><ol>
<li>register的使用（navigation那里）<br>①先把问题转化成有限状态机，再把有限状态机实现成电路<br>②每个时钟上升沿到来，更新寄存器的值</li>
<li>三态问题？什么时候用三态？（好像三态的输入用逻辑门运算会变红）<br>不用考虑三态</li>
<li>二进制减法qaq不会（主要是ftoi那里）<br>扩展为32位，再用0去减<br>用0去减其实与非门等效</li>
</ol>
<h2 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset/CRC%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF.png"
                      alt="1"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset/CRC%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B.png"
                      alt="1"
                ></p>
<ol>
<li>体现了模块化的思想</li>
<li>要审题，题目说了被除数是要拼接的</li>
<li>注意splitter的最高位最低位以及数据的最高位最低为的对应，不要反了！</li>
</ol>
<h2 id="GRF"><a href="#GRF" class="headerlink" title="GRF"></a>GRF</h2><p>题目不难，注意线路很杂的时候要看有没有接上或者接错，CTRL CV 的时候tunnel要改完改对</p>
<h2 id="ftoi"><a href="#ftoi" class="headerlink" title="ftoi"></a>ftoi</h2><ol>
<li>二进制浮点数小数点几位，相当于右移几位；乘2^n想当于左移（正数），注意要先左移再右移，否则就丢失掉后面的数据位了</li>
<li>二进制减法？不会qaq</li>
<li>计算负数的补码，取反（非门计算）+1，（？2^n-x感觉是不是不太行，因为n达不到32位） </li>
<li>学会试着使用simulate-logging功能debug</li>
</ol>
<h2 id="navigation"><a href="#navigation" class="headerlink" title="navigation"></a>navigation</h2><ol>
<li>状态转移打表 “课上课下打表最经济有效”————董老 salute！<br>此处状态转移以及hit都可以打表得到（注意打表的时候输入输出都只能是一位，这里需要splitter套层皮，同样是注意高低位）</li>
<li>太憨了！看好输入输出要求，是否提供clk，如果clk是一个input就不要再自己放一个clk了，太憨。</li>
<li>注意状态存储部分要符合题目要求</li>
<li>状态转移打表、register存储、input和prev_state决定输出，这些没什么好说的</li>
<li>What deserves special mention is 注意这里利用MUX实现了同步复位，因为后面有register，只有clk处于上升沿，这个clr才是有效的（组合逻辑是不是们没有任何延迟？目前是的）</li>
</ol>
<h2 id="祝上机顺利！"><a href="#祝上机顺利！" class="headerlink" title="祝上机顺利！"></a>祝上机顺利！</h2>]]></content>
  </entry>
</search>
